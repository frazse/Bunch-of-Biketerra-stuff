// ==UserScript==
// @name         Biketerra ITT Result Display Optimized v3.3
// @namespace    http://tampermonkey.net/
// @version      3.3
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function () {
    'use strict';

    let myName = "You";
    let results = [];
    let overlay, list, rowMap = {};

    let lastSeconds = 0;
    let running = false;
    let isRaceActive = false;
    let pausedTimeSeconds = 0;
    let lastUpdatePerf = performance.now();
    let lastTimerText = "00:00";

    const SORT_COOLDOWN_MS = 500; // Sorting update cooldown
    const UPDATE_INTERVAL = 300; // ms throttle for overlay updates
    let lastSortTime = 0;
    let lastUpdateTime = 0;
    let sortableTime = 0;

    // --- Medal Helper ---
    function medalForPos(pos) {
        switch (pos) {
            case 1: return "ü•á";
            case 2: return "ü•à";
            case 3: return "ü•â";
            default: return pos;
        }
    }

    // --- Overlay Skeleton with Hide Button ---
// --- Overlay Skeleton with Hide and Refresh Buttons ---
function createOverlaySkeleton() {
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'bt-results-overlay';
        document.body.appendChild(overlay);

        Object.assign(overlay.style, {
            position: 'fixed', top: '8px', left: '8px',
            background: 'rgba(0,0,0,0.65)', color: 'white',
            padding: '8px', borderRadius: '10px',
            fontFamily: 'sans-serif', fontSize: '14px',
            zIndex: 999999, boxShadow: '0 4px 10px rgba(0,0,0,0.25)',
            backdropFilter: 'blur(4px)',
            maxWidth: '360px', maxHeight: '50%',
            overflowY: 'auto',
        });

        // Header with title, hide and refresh buttons
        overlay.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <div style="font-weight:700;">üèÅ Race Results</div>
                <div>
                    <button id="bt-refresh-btn" style="background:transparent; color:white; border:none; cursor:pointer; font-size:14px; margin-right:0px;">‚ü≥</button>
                    <button id="bt-hide-btn" style="background:transparent; color:white; border:none; cursor:pointer; font-size:14px;">üóï</button>
                </div>
            </div>
            <div class="list"></div>`;

        list = overlay.querySelector('.list');

        const hideBtn = overlay.querySelector('#bt-hide-btn');
        hideBtn.addEventListener('click', () => {
            if (list.style.display === 'none') {
                list.style.display = 'block';
                hideBtn.textContent = 'üóï';
            } else {
                list.style.display = 'none';
                hideBtn.textContent = '‚ñ¢';
            }
        });

        const refreshBtn = overlay.querySelector('#bt-refresh-btn');
        refreshBtn.addEventListener('click', () => {
            extractResults(); // Re-fetch the results from the table
        });

        if (!document.getElementById('bt-results-overlay-style')) {
            const style = document.createElement('style');
            style.id = 'bt-results-overlay-style';
            style.textContent = `
            #bt-results-overlay::-webkit-scrollbar { width:8px; height:8px; }
            #bt-results-overlay::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius:4px; }
            #bt-results-overlay::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius:4px; }
            #bt-results-overlay::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.5); }
            #bt-results-overlay { scrollbar-width: thin; scrollbar-color: rgba(255,255,255,0.3) rgba(0,0,0,0.2); }`;
            document.head.appendChild(style);
        }
    }
}

    // --- Overlay Update ---
    function updateOverlay(entries) {
        createOverlaySkeleton();

        let needReorder = false;

        entries.forEach(({pos, name, time}) => {
            let row = rowMap[name];
            if (!row) {
                row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.justifyContent = 'space-between';
                row.style.margin = '0';
                row.style.padding = '1px 0';
                row.style.backgroundColor = (name === myName) ? 'rgba(255,255,255,0.1)' : 'transparent';

                const posSpan = document.createElement('span');
                posSpan.style.width = '2em';
                posSpan.style.textAlign = 'right';
                posSpan.className = 'pos';
                row.appendChild(posSpan);

                const nameSpan = document.createElement('span');
                nameSpan.style.flex = '1';
                nameSpan.style.margin = '0 8px';
                nameSpan.textContent = name;
                row.appendChild(nameSpan);

                const timeSpan = document.createElement('span');
                timeSpan.style.fontFamily = 'monospace';
                timeSpan.className = 'time';
                row.appendChild(timeSpan);

                rowMap[name] = row;
                needReorder = true;
            }

            const posEl = row.querySelector('.pos');
            const timeEl = row.querySelector('.time');

            const medal = medalForPos(pos);
            if (posEl.textContent !== medal) posEl.textContent = medal;
            if (timeEl.textContent !== time) timeEl.textContent = time;
        });

        const currentOrder = entries.map(e => e.name).join();
        if (needReorder || updateOverlay.lastOrder !== currentOrder) {
            const fragment = document.createDocumentFragment();
            entries.forEach(({name}) => fragment.appendChild(rowMap[name]));
            list.appendChild(fragment);
            updateOverlay.lastOrder = currentOrder;
        }

        // Scroll "You" into view at most once per second
        if (rowMap[myName] && (!updateOverlay.lastScroll || Date.now() - updateOverlay.lastScroll > 1000)) {
            rowMap[myName].scrollIntoView({ behavior: 'smooth', block: 'center' });
            updateOverlay.lastScroll = Date.now();
        }
    }

    // --- Extract Results ---
function extractResults() {
    const table = document.querySelector('.menu-body .grid-table.race-results');
    if (!table) return false;

    const cells = Array.from(table.children);
    if (!cells.length) return false;

    const headerCount = 3;
    const rows = [];
    for (let i = headerCount; i < cells.length; i += headerCount) {
        const row = cells.slice(i, i + headerCount);
        if (row.length < 3) continue;

        const pos = row[0].innerText.trim();
        const name = row[1].innerText.trim();
        const time = row[2].innerText.trim();

        // --- Only include riders with valid time ---
        if (time && time !== "--") {
        //    rows.push({ pos, name, time });
            rows.push({ pos: rows.length + 1, name, time });

        }

    }

    results = rows;
    updateOverlay(results);
    return true;
}

    // --- Time Utilities ---
    function parseTimeToSeconds(t) {
        if (!t || t === "--") return Infinity;
        const parts = t.split(/[:.]/);
        let seconds = 0;
        if (parts.length === 3) seconds = parseFloat(parts[0])*60 + parseFloat(parts[1]) + parseFloat(`0.${parts[2]}`);
        else if (parts.length === 2) seconds = parseFloat(parts[0])*60 + parseFloat(parts[1]);
        return seconds;
    }

    function formatTime(seconds) {
        if (seconds === Infinity) return "--";
        const min = Math.floor(seconds/60);
        const sec = Math.floor(seconds % 60);
        const ms = Math.floor((seconds - Math.floor(seconds))*1000);
        return `${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
    }

    // --- Update My Position ---
    function updateMyPosition() {
        const now = performance.now();
        if (now - lastUpdateTime < UPDATE_INTERVAL) return; // throttle
        lastUpdateTime = now;

        const timerEl = document.querySelector('.activity-timer-time.monospace');
        if (!timerEl) { isRaceActive=false; running=false; return; }

        isRaceActive = true;
        const currentText = timerEl.textContent.trim();
        const currentSeconds = parseTimeToSeconds(currentText);

        if (currentText !== lastTimerText) {
            lastTimerText = currentText;
            lastSeconds = currentSeconds;
            lastUpdatePerf = now;
            running = true;
            pausedTimeSeconds = 0;
        } else if (running && now - lastUpdatePerf > 1000) {
            running = false;
            pausedTimeSeconds = lastSeconds;
        }

        let total = running ? lastSeconds + (now - lastUpdatePerf)/1000 : pausedTimeSeconds || 0;

        if (now - lastSortTime > SORT_COOLDOWN_MS || !running) {
            sortableTime = total;
            lastSortTime = now;
        }

        const myEntry = { pos:"-", name:myName, time:formatTime(total), sortTime:formatTime(sortableTime) };
        const combined = [...results.map(r=>({...r, sortTime:r.time})), myEntry];

        combined.sort((a,b) => parseTimeToSeconds(a.sortTime) - parseTimeToSeconds(b.sortTime));
        combined.forEach((r,i) => r.pos = i+1);

        updateOverlay(combined);
    }

    // --- Watch Timer ---
    function startWatchingTimer() {
        const timerEl = document.querySelector('.activity-timer-time.monospace');
        if (!timerEl) return;

        const observer = new MutationObserver(updateMyPosition);
        observer.observe(timerEl, { childList:true, subtree:true, characterData:true });

        function tick() {
            const now = performance.now();
            if (!tick.lastUpdate || now - tick.lastUpdate > 100) {
                if (isRaceActive) updateMyPosition();
                tick.lastUpdate = now;
            }
            requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
    }
function watchKmToGoValue() {
    // Select the actual number element, not the label
    const kmToGoEl = Array.from(document.querySelectorAll('.stat-row-split.stat-avg .avg-value'))
                           .find(el => parseFloat(el.textContent) > 0 || parseFloat(el.textContent) === 0);

    if (!kmToGoEl) return;

    const observer = new MutationObserver(() => {
        const km = parseFloat(kmToGoEl.textContent);
        if (!isNaN(km) && km <= 0) {
            extractResults(); // refresh overlay when km hits 0
            console.log("[ITT Result] 0 KM to go hit, Refreshing Race Results")
        }
    });

    observer.observe(kmToGoEl, { characterData: true, childList: true, subtree: true });
}

    // --- Main Observer ---
    const mainObserver = new MutationObserver(() => {
        const table = document.querySelector('.menu-body .grid-table.race-results');
        const timerEl = document.querySelector('.activity-timer-time.monospace');

        if (table && extractResults() && timerEl) {
            mainObserver.disconnect();
            startWatchingTimer();
        } else if (!table && !timerEl && overlay) {
            overlay.remove(); overlay=null; rowMap={};
        }
    });

    mainObserver.observe(document.body,{childList:true,subtree:true});
})();
