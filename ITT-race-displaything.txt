// ==UserScript==
// @name Â  Â  Â  Â  Biketerra ITT Result Display thingy
// @namespace Â  Â http://tampermonkey.net/
// @version Â  Â  Â 3.0 // Updated version number
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @grant Â  Â  Â  Â none
// ==/UserScript==

(function () {
Â  Â  'use strict';

Â  Â  let myName = "You";
Â  Â  let results = [];
Â  Â  let overlay;

Â  Â  let lastSeconds = 0;
Â  Â  let running = false;
    let isRaceActive = false;
    let pausedTimeSeconds = 0;
    let lastUpdatePerf = performance.now();
    let lastTimerText = "00:00";

    // --- New Variables for Stability ---
    const SORT_COOLDOWN_MS = 500; // Only recalculate sort position every 500ms
    let lastSortTime = 0;
    let sortableTime = 0; // The time value used for sorting (updated less frequently)
    // ------------------------------------

Â  Â  function medalForPos(pos) {
Â  Â  Â  Â  switch (pos) {
Â  Â  Â  Â  Â  Â  case 1: return "ğŸ¥‡";
Â  Â  Â  Â  Â  Â  case 2: return "ğŸ¥ˆ";
Â  Â  Â  Â  Â  Â  case 3: return "ğŸ¥‰";
Â  Â  Â  Â  Â  Â  default: return pos;
Â  Â  Â  Â  }
Â  Â  }

function createOverlay(entries) {
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'bt-results-overlay';
        document.body.appendChild(overlay);

        Object.assign(overlay.style, {
            position: 'fixed',
            top: '8px',
            left: '8px',
            background: 'rgba(0, 0, 0, 0.65)',
            color: 'white',
            padding: '8px',
            borderRadius: '10px',
            fontFamily: 'sans-serif',
            fontSize: '14px',
            zIndex: 999999,
            boxShadow: '0 4px 10px rgba(0, 0, 0, 0.25)',
            backdropFilter: 'blur(4px)',
            maxWidth: '360px',
            maxHeight: '50%',
            overflowY: 'auto',
        });
    }

    overlay.innerHTML = `
        <div style="font-weight:700;margin-bottom:4px;">ğŸ Race Results</div>
        <div class="list"></div>
    `;
    const list = overlay.querySelector('.list');

let myRowIndex = -1; // keep track of my row's index
entries
  .filter(entry => entry.time && entry.time !== "--") // only include valid times
  .forEach(({ pos, name, time }, i) => {
      const div = document.createElement('div');
      div.style.display = 'flex';
      div.style.alignItems = 'center';
      div.style.justifyContent = 'space-between';
      div.style.margin = '0';
      div.style.padding = '1px 0';
      div.style.backgroundColor = (name === myName) ? 'rgba(255,255,255,0.1)' : 'transparent';

      const posSpan = document.createElement('span');
      posSpan.style.width = '2em';
      posSpan.style.textAlign = 'right';
      posSpan.textContent = medalForPos(pos);

      const nameSpan = document.createElement('span');
      nameSpan.style.flex = '1';
      nameSpan.style.margin = '0 8px';
      nameSpan.textContent = name;

      const timeSpan = document.createElement('span');
      timeSpan.style.fontFamily = 'monospace';
      timeSpan.textContent = time;

      div.appendChild(posSpan);
      div.appendChild(nameSpan);
      div.appendChild(timeSpan);

      list.appendChild(div);

      if(name === myName) myRowIndex = i;
});


    // Scroll my row into view
    const children = Array.from(list.children);
    if (myRowIndex >= 0 && myRowIndex < children.length) {
        children[myRowIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}
// Add this once at the top after creating the overlay
if (!document.getElementById('bt-results-overlay-style')) {
    const style = document.createElement('style');
    style.id = 'bt-results-overlay-style';
    style.textContent = `
    /* Scrollbar for bt-results-overlay */
    #bt-results-overlay::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }
    #bt-results-overlay::-webkit-scrollbar-track {
        background: rgba(0,0,0,0.2);
        border-radius: 4px;
    }
    #bt-results-overlay::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.3);
        border-radius: 4px;
    }
    #bt-results-overlay::-webkit-scrollbar-thumb:hover {
        background: rgba(255,255,255,0.5);
    }

    /* Firefox */
    #bt-results-overlay {
        scrollbar-width: thin;
        scrollbar-color: rgba(255,255,255,0.3) rgba(0,0,0,0.2);
    }
    `;
    document.head.appendChild(style);
}

Â  Â  function extractResults() {
Â  Â  Â  Â  const table = document.querySelector('.menu-body .grid-table.race-results');
Â  Â  Â  Â  if (!table) return false;

Â  Â  Â  Â  const cells = Array.from(table.children);
Â  Â  Â  Â  if (!cells.length) return false;

Â  Â  Â  Â  const headerCount = 3;
Â  Â  Â  Â  const rows = [];
Â  Â  Â  Â  for (let i = headerCount; i < cells.length; i += headerCount) {
Â  Â  Â  Â  Â  Â  const row = cells.slice(i, i + headerCount);
Â  Â  Â  Â  Â  Â  if (row.length < 3) continue;
Â  Â  Â  Â  Â  Â  const pos = row[0].innerText.trim();
Â  Â  Â  Â  Â  Â  const name = row[1].innerText.trim();
Â  Â  Â  Â  Â  Â  const time = row[2].innerText.trim();
Â  Â  Â  Â  Â  Â  rows.push({ pos, name, time });
Â  Â  Â  Â  }

Â  Â  Â  Â  results = rows;
Â  Â  Â  Â  createOverlay(results);
Â  Â  Â  Â  return true;
Â  Â  }

Â  Â  function parseTimeToSeconds(t) {
Â  Â  Â  Â  if (!t || t === "--") return Infinity;
Â  Â  Â  Â  const parts = t.split(/[:.]/);
        let seconds = 0;

        if (parts.length === 3) {
            seconds = parseFloat(parts[0]) * 60 + parseFloat(parts[1]) + parseFloat(`0.${parts[2]}`);
        } else if (parts.length === 2) {
            seconds = parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
        }
Â  Â  Â  Â  return seconds;
Â  Â  }

Â  Â  function formatTime(seconds) {
        if (seconds === Infinity) return "--";

Â  Â  Â  Â  const min = Math.floor(seconds / 60);
Â  Â  Â  Â  const sec = Math.floor(seconds % 60);
Â  Â  Â  Â  const ms = Math.floor((seconds - Math.floor(seconds)) * 1000);

Â  Â  Â  Â  return `${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
Â  Â  }

Â  Â  function updateMyPosition() {
Â  Â  Â  Â  const timerEl = document.querySelector('.activity-timer-time.monospace');
Â  Â  Â  Â  if (!timerEl) {
            isRaceActive = false;
            running = false;
            return;
        }

        isRaceActive = true;
        const now = performance.now();

Â  Â  Â  Â  const currentText = timerEl.textContent.trim();
Â  Â  Â  Â  const currentSeconds = parseTimeToSeconds(currentText);

Â  Â  Â  Â  // Timer Running Detection
Â  Â  Â  Â  if (currentText !== lastTimerText) {
Â  Â  Â  Â  Â  Â  lastTimerText = currentText;
Â  Â  Â  Â  Â  Â  lastSeconds = currentSeconds;
Â  Â  Â  Â  Â  Â  lastUpdatePerf = now;
Â  Â  Â  Â  Â  Â  running = true;
            pausedTimeSeconds = 0;
Â  Â  Â  Â  } else if (running && now - lastUpdatePerf > 1000) {
            // Timer has stopped (no change for over 1s)
            running = false;
            pausedTimeSeconds = lastSeconds;
Â  Â  Â  Â  }

Â  Â  Â  Â  let total;
Â  Â  Â  Â  if (running) {
Â  Â  Â  Â  Â  Â  // Real-time calculation for display
Â  Â  Â  Â  Â  Â  total = lastSeconds + (now - lastUpdatePerf) / 1000;
Â  Â  Â  Â  } else if (pausedTimeSeconds > 0) {
            // Use locked-in time if paused
            total = pausedTimeSeconds;
        } else {
            // Default (e.g., waiting for start)
            total = 0;
        }

        // --- Stability Logic ---
        // Only update the time used for SORTING every 500ms (SORT_COOLDOWN_MS)
        if (now - lastSortTime > SORT_COOLDOWN_MS || !running) {
            sortableTime = total;
            lastSortTime = now;
        } else if (sortableTime === 0) {
             // Ensure it's initialized immediately when the race starts
             sortableTime = total;
        }
        // -----------------------

        // Create the entry for "You" using the real-time for display, but sortableTime for parsing
        const myEntry = {
            pos: "-",
            name: myName,
            time: formatTime(total),
            sortTime: formatTime(sortableTime) // Add a new property for sorting
        };

Â  Â  Â  Â  const combined = [...results.map(r => ({...r, sortTime: r.time})), myEntry];

        // Sort using the less-frequently updated time (sortableTime)
Â  Â  Â  Â  combined.sort((a,b)=> parseTimeToSeconds(a.sortTime) - parseTimeToSeconds(b.sortTime));

Â  Â  Â  Â  combined.forEach((r,i)=> r.pos = i+1);

Â  Â  Â  Â  createOverlay(combined);
Â  Â  }

Â  Â  function startWatchingTimer() {
Â  Â  Â  Â  const timerEl = document.querySelector('.activity-timer-time.monospace');
Â  Â  Â  Â  if (!timerEl) return;

Â  Â  Â  Â  const observer = new MutationObserver(updateMyPosition);
Â  Â  Â  Â  observer.observe(timerEl, { childList:true, subtree:true, characterData:true });

Â  Â  Â  Â  function tick() {
Â  Â  Â  Â  Â  Â  if (isRaceActive) {
                // This tick handles the millisecond update and stability check
                updateMyPosition();
            }
Â  Â  Â  Â  Â  Â  requestAnimationFrame(tick);
Â  Â  Â  Â  }
Â  Â  Â  Â  requestAnimationFrame(tick);
Â  Â  }

Â  Â  const mainObserver = new MutationObserver(() => {
Â  Â  Â  Â  const table = document.querySelector('.menu-body .grid-table.race-results');
        const timerEl = document.querySelector('.activity-timer-time.monospace');

Â  Â  Â  Â  if (table && extractResults() && timerEl) {
            mainObserver.disconnect();
Â  Â  Â  Â  Â  Â  startWatchingTimer();
Â  Â  Â  Â  } else if (!table && !timerEl && overlay) {
            overlay.remove();
            overlay = null;
        }
Â  Â  });

Â  Â  mainObserver.observe(document.body,{childList:true,subtree:true});
})();
