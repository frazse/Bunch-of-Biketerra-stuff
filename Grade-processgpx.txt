// ==UserScript==
// @name         Biketerra Climb Overlay (Fixed Stats + Active Update)
// @namespace    http://tampermonkey.net/
// @version      1.4
// @description  Show route climbs overlay with fixed total_km/climb and updating active climb
// @match        https://biketerra.com/ride*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=biketerra.com
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // =========================
    // Parameters
    // =========================
    const MIN_AVG_GRADE = 2;
    const MIN_GAIN_M = 100;
    const MERGE_MAX_GAP_KM = 0.25;
    const MAX_GRADE_DRAW = 15;
    const ACTIVE_UPDATE_INTERVAL = 200; // ms

    // =========================
    // State
    // =========================
    let total_km = null;
    let total_climb = null;
    let points = null;
    let climbs = [];

    // =========================
    // Helper functions
    // =========================
    function extractStats() {
        const statRows = document.querySelectorAll(".stat-row");
        if (statRows.length < 4) return null;

        const distEl = statRows[2].querySelector(".stat-row-split.stat-avg .avg-value");
        const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
        if (!distEl || !climbEl) return null;

        return {
            total_km: parseFloat(distEl.textContent.trim().replace(",", ".").replace(" km", "")),
            total_climb: parseFloat(climbEl.textContent.trim().replace(",", "."))
        };
    }

    function getPolylinePoints() {
        const polyline = document.querySelector('polyline[stroke-width="2"]');
        if (!polyline) return null;

        return polyline.getAttribute("points").trim().split(/\s+/).map(p => {
            const [x, y] = p.split(",").map(parseFloat);
            return { x, y };
        });
    }

    function computeClimbs(points, total_km, total_climb) {
        if (!points || points.length < 2) return [];

        const elev = points.map(p => (1 - p.y) * total_climb);
        const dist = points.map((p, i) => (i / (points.length-1)) * total_km);

        const climbs = [];
        let climbStart = null;
        for (let i = 1; i < elev.length; i++) {
            if (elev[i] > elev[i-1]) {
                if (climbStart === null) climbStart = i-1;
            } else {
                if (climbStart !== null) {
                    climbs.push({ start: climbStart, end: i-1 });
                    climbStart = null;
                }
            }
        }
        if (climbStart !== null) climbs.push({ start: climbStart, end: elev.length-1 });

        return climbs.map(c => {
            const gain = Math.max(0, elev[c.end] - elev[c.start]);
            const lengthKm = dist[c.end] - dist[c.start];
            const avgGrade = lengthKm > 0 ? (gain / (lengthKm*1000))*100 : 0;
            return {
                startKm: dist[c.start],
                endKm: dist[c.end],
                gain: Math.round(gain),
                avgGrade: Number(avgGrade.toFixed(1))
            };
        });
    }

    function mergeCloseClimbs(climbs) {
        if (climbs.length === 0) return [];
        const merged = [];
        let prev = climbs[0];
        for (let i = 1; i < climbs.length; i++) {
            const curr = climbs[i];
            const gap = curr.startKm - prev.endKm;
            if (gap <= MERGE_MAX_GAP_KM) {
                prev = {
                    startKm: prev.startKm,
                    endKm: curr.endKm,
                    gain: prev.gain + curr.gain,
                    avgGrade: Number(((prev.avgGrade + curr.avgGrade)/2).toFixed(1))
                };
            } else {
                merged.push(prev);
                prev = curr;
            }
        }
        merged.push(prev);
        return merged;
    }

    function createOverlay(id, bottomPx, heightPx, zIndex) {
        let existing = document.getElementById(id);
        if (existing) return existing.querySelector("canvas");

        const overlay = document.createElement("div");
        overlay.id = id;
        overlay.style.position = "fixed";
        overlay.style.bottom = bottomPx + "px";
        overlay.style.left = "50%";
        overlay.style.transform = "translateX(-50%)";
        overlay.style.width = "43vw";
        overlay.style.height = "150px";
        overlay.style.background = "rgba(0,0,0,0.3)";
       // overlay.style.border = "1px solid #fff";
        overlay.style.zIndex = zIndex;

        const canvas = document.createElement("canvas");
        overlay.appendChild(canvas);
        document.body.appendChild(overlay);

        requestAnimationFrame(() => {
            const rect = overlay.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            canvas.style.width = "100%";
            canvas.style.height = "100%";
        });

        return canvas;
    }

  /*  function drawClimbsOverlay(climbs) {
        const canvas = createOverlay("climbOverlay", 8, 95, 9999);
        const ctx = canvas.getContext("2d");
        if (!climbs || climbs.length === 0) return;

        if (canvas.width === 0 || canvas.height === 0) {
            setTimeout(() => drawClimbsOverlay(climbs), 50);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        climbs.filter(c => c.avgGrade >= MIN_AVG_GRADE && c.gain >= MIN_GAIN_M)
            .forEach(c => {
                const xStart = (c.startKm / total_km) * canvas.width;
                const xEnd = (c.endKm / total_km) * canvas.width;
                const rectX = Math.min(xStart, xEnd);
                const width = Math.abs(xEnd - xStart);
                const height = Math.min(canvas.height, (c.avgGrade / MAX_GRADE_DRAW) * canvas.height);

                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.fillRect(rectX, canvas.height - height, width, height);

                ctx.fillStyle = "#fff";
                ctx.font = "12px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(`${c.gain}m / ${c.avgGrade}%`, rectX + width/2, 14);
            });
    }
*/
function drawActiveClimbOverlay(points, climbs, total_km, myKm) {
    const canvas = createOverlay("activeClimbOverlay", 110, 60, 10000);
    const ctx = canvas.getContext("2d");
    if (!points || climbs.length === 0 || myKm == null) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Find active climb
    const activeClimb = climbs.find(c => myKm >= c.startKm && myKm <= c.endKm);
    if (!activeClimb) return;

    // Set zoom window
    const zoomStartKm = Math.max(0, activeClimb.startKm - (activeClimb.endKm - activeClimb.startKm) * 0.2);
    const zoomEndKm   = Math.min(total_km, activeClimb.endKm + (activeClimb.endKm - activeClimb.startKm) * 0.2);

    const kmToX = km => ((km - zoomStartKm) / (zoomEndKm - zoomStartKm)) * canvas.width;

    // --- DRAW CLIMBS IN ZOOM WINDOW ---
    climbs.filter(c => c.avgGrade >= MIN_AVG_GRADE && c.gain >= MIN_GAIN_M)
        .forEach(climb => {

            const startIndex = points.findIndex((p, i) => (i / (points.length-1)) * total_km >= climb.startKm);
            const endIndex   = points.findIndex((p, i) => (i / (points.length-1)) * total_km >= climb.endKm);
            if (startIndex === -1 || endIndex === -1) return;

            ctx.beginPath();
            for (let i = startIndex; i <= endIndex; i++) {
                const km = (i / (points.length-1)) * total_km;
                if (km < zoomStartKm || km > zoomEndKm) continue;

                const x = kmToX(km);
                const y = canvas.height - Math.min(
                    canvas.height,
                    Math.abs(points[i].y - points[startIndex].y) * MAX_GRADE_DRAW * 5
                );

                if (i === startIndex || km === zoomStartKm) ctx.moveTo(x, canvas.height);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(kmToX(climb.endKm), canvas.height);
            ctx.closePath();

            const isActive = (climb === activeClimb);
            ctx.fillStyle = isActive ? "rgba(0,128,255,0.8)" : "rgba(0,128,255,0.4)";
            ctx.fill();
        });

    // --- DRAW CENTERED LABEL (ONCE) ---
    const xCenter = canvas.width / 2;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 14px Overpass, sans-serif";
    ctx.textAlign = "center";
    // --- COMPUTE EXTRA CLIMB DATA ---

// 1. Climb position: "Climb X/X"
const climbIndex = climbs.indexOf(activeClimb) + 1;
const climbTotal = climbs.length;

// 2. Distance remaining on the climb
const remainingKm = Math.max(0, activeClimb.endKm - myKm);
const remainingMeters = Math.round(remainingKm * 1000);

// 3. Avg grade remaining
//    Recompute average grade only for the remaining portion
let remGain = 0;
let remDist = 0;
for (let i = 0; i < points.length - 1; i++) {
    const kmHere = (i / (points.length - 1)) * total_km;
    if (kmHere < myKm || kmHere > activeClimb.endKm) continue;

    const dy = points[i + 1].y - points[i].y;
    const dx = (total_km / (points.length - 1)) * 1000;
    if (dy > 0) remGain += dy;
    remDist += dx;
}
    const remainingHeight = (activeClimb.endKm - myKm) > 0  ? activeClimb.gain * (remainingKm / (activeClimb.endKm - activeClimb.startKm)) : 0;
// Compute remaining elevation on climb using points
let lastY = null;
for (let i = 0; i < points.length; i++) {
    const kmHere = (i / (points.length - 1)) * total_km;
    if (kmHere < myKm) continue;
    if (kmHere > activeClimb.endKm) break;

    if (lastY !== null) {
        const dy = points[i].y - lastY;
        if (dy > 0) remainingHeight += dy * total_climb; // scale by total climb
    }
    lastY = points[i].y;
}

// Remaining distance in meters
const remainingDistMeters = remainingKm * 1000;

// Remaining grade
const remainingGrade = remainingDistMeters > 0
    ? (remainingHeight / remainingDistMeters) * 100
    : 0;


// 4. Time calculations
// Store when climb started if not already stored
if (!activeClimb.__startTime && myKm >= activeClimb.startKm) {
    activeClimb.__startTime = performance.now();
}

// Elapsed time
let elapsedSec = 0;
if (activeClimb.__startTime) {
    elapsedSec = Math.floor((performance.now() - activeClimb.__startTime) / 1000);
}
const elapsedMin = Math.floor(elapsedSec / 60);
const elapsedSec2 = elapsedSec % 60;

// ETA until climb end (if rider speed is known)
let etaStr = "??:??";
if (window.lastSpeedKph && window.lastSpeedKph > 1) {
    const speedMps = window.lastSpeedKph / 3.6;
    const etaSec = Math.floor(remainingMeters / speedMps);
    const etaMin = Math.floor(etaSec / 60);
    const etaSec2 = etaSec % 60;
    etaStr = `${etaMin}:${etaSec2.toString().padStart(2, "0")}`;
}

// Format elapsed as mm:ss
const elapsedStr = `${elapsedMin}:${elapsedSec2.toString().padStart(2,'0')}`;

// --- DRAW CENTERED MULTI-LINE LABEL ---
ctx.fillStyle = "#fff";
ctx.font = "bold 16px Overpass, sans-serif";
ctx.textAlign = "center";

ctx.fillText(
    `Climb ${climbIndex}/${climbTotal} | Remaining: ${remainingKm.toFixed(2)} km | ${remainingGrade.toFixed(1)}%`,
    xCenter, 20
);


ctx.fillText(
    `ETA: ${etaStr} | Elapsed: ${elapsedStr}`,
    xCenter, 38
);

 //   ctx.fillText(`${activeClimb.gain}m / ${activeClimb.avgGrade}%`, xCenter, 20);


    // --- DRAW CURRENT POSITION MARKER ---
    if (myKm >= zoomStartKm && myKm <= zoomEndKm) {
        const riderX = kmToX(myKm);

        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(riderX, 0);
        ctx.lineTo(riderX, canvas.height);
        ctx.stroke();
    }
}

// Grab current speed in KPH
function updateSpeed() {
    const statRows = document.querySelectorAll(".stat-row");
    if (statRows.length < 1) return null;

    // statRows[0] = row with current speed
    const speedEl = statRows[0].querySelector(".stat-row-split .stat-value");
    if (!speedEl) return null;

    const val = parseFloat(speedEl.textContent.trim().replace(",", "."));
    if (!isNaN(val)) {
        window.lastSpeedKph = val;
        return val;
    }

    return null;
}

setInterval(updateSpeed, 500);

function getMyKm() {
    const statRows = document.querySelectorAll(".stat-row");
    if (statRows.length < 4 || total_km == null) return null;

    // statRows[2] = remaining km (counts down)
    const remEl = statRows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!remEl) return null;

    const remaining = parseFloat(remEl.textContent.trim().replace(",", "."));
    if (isNaN(remaining)) return null;

    // progress = total - remaining
    const myKm = total_km - remaining;

    return myKm < 0 ? 0 : myKm;
}

    // =========================
    // Initialization
    // =========================
    function initOverlays() {
        // Wait until DOM is ready
        const stats = extractStats();
        const poly = getPolylinePoints();
        if (!stats || !poly) return false;

        total_km = stats.total_km;
        total_climb = stats.total_climb;
        points = poly;

        climbs = computeClimbs(points, total_km, total_climb);
        climbs = mergeCloseClimbs(climbs);

        console.log("======== ROUTE CLIMB ANALYSIS (Fixed Stats) ========");
        console.table(climbs);

        //drawClimbsOverlay(climbs);

        return true;
    }

    // Try initializing every 500ms until success
    const initInterval = setInterval(() => {
        if (initOverlays()) clearInterval(initInterval);
    }, 500);

    // =========================
    // Active climb updating
    // =========================
setInterval(() => {
    if (total_km && points && climbs.length) {
        const myKm = getMyKm();
        drawActiveClimbOverlay(points, climbs, total_km, myKm);
    }
}, ACTIVE_UPDATE_INTERVAL);

})();
