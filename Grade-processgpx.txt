// ==UserScript==
// @name         Biketerra Climb Overlay (Fixed Stats + Active Update, True Gains)
// @namespace    http://tampermonkey.net/
// @version      1.6
// @description  Shows climbs with fixed stats + active climb overlay matching polyline shape
// @match        https://biketerra.com/ride*
// @grant        none
// ==/UserScript==

(function() {
'use strict';

// -------------------------
// PARAMETERS
// -------------------------
const MIN_AVG_GRADE = 2;
const MIN_GAIN_M = 100;
const MERGE_MAX_GAP_KM = 0.25;
const MAX_GRADE_DRAW = 15;
const ACTIVE_UPDATE_INTERVAL = 200;

// Color thresholds
const GRADE_COLORS = [
    { grade: 0, color: "#00FF00" },
    { grade: 3, color: "#FFFF00" },
    { grade: 6, color: "#FFA500" },
    { grade: 9, color: "#FF4500" },
    { grade: 12, color: "#800080" }
];

function gradeToColor(g) {
    for (let i = GRADE_COLORS.length - 1; i >= 0; i--) {
        if (g >= GRADE_COLORS[i].grade) return GRADE_COLORS[i].color;
    }
    return GRADE_COLORS[0].color;
}

// -------------------------
// STATE
// -------------------------
let total_km = null;
let total_climb = null;
let points = null;
let climbs = [];

// -------------------------
// HELPERS
// -------------------------
function extractStats() {
    const statRows = document.querySelectorAll(".stat-row");
    if (statRows.length < 4) return null;

    const distEl = statRows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!distEl || !climbEl) return null;

    return {
        total_km: parseFloat(distEl.textContent.trim().replace(",", ".").replace(" km", "")),
        total_climb: parseFloat(climbEl.textContent.trim().replace(",", "."))
    };
}

function getPolylinePoints() {
    const polyline = document.querySelector('polyline[stroke-width="2"]');
    if (!polyline) return null;

    return polyline.getAttribute("points").trim().split(/\s+/).map(p => {
        const [x, y] = p.split(",").map(parseFloat);
        return { x, y };
    });
}

// -------------------------
// CLIMB COMPUTATION
// -------------------------
function computeClimbsAccurate(points, total_km, total_climb) {
    if (!points || points.length < 2) return [];

    // normalize y (invert)
    const elevNorm = points.map(p => 1 - p.y);
    let posSum = 0;
    for (let i = 1; i < elevNorm.length; i++) {
        const d = elevNorm[i] - elevNorm[i-1];
        if (d > 0) posSum += d;
    }
    const scale = total_climb / posSum;
    const elev = elevNorm.map(v => v * scale);

    const dist = points.map((p,i) => (i / (points.length-1)) * total_km);

    const climbsRaw = [];
    let start = 0;
    let inClimb = false;

    for (let i = 1; i < elev.length; i++) {
        const dy = elev[i] - elev[i-1];
        if (dy > 0) {
            if (!inClimb) {
                start = i-1;
                inClimb = true;
            }
        } else {
            if (inClimb) {
                climbsRaw.push({ start, end: i-1 });
                inClimb = false;
            }
        }
    }
    if (inClimb) climbsRaw.push({ start, end: elev.length-1 });

    return climbsRaw.map(c => {
        let gain = 0;
        for (let i = c.start+1; i <= c.end; i++) {
            const d = elev[i] - elev[i-1];
            if (d > 0) gain += d;
        }
        const lengthKm = dist[c.end] - dist[c.start];
        const avgGrade = lengthKm > 0 ? (gain/(lengthKm*1000))*100 : 0;

        return {
            startKm: dist[c.start],
            endKm: dist[c.end],
            gain: Math.round(gain),
            avgGrade: Number(avgGrade.toFixed(1))
        };
    });
}

function mergeCloseClimbsAccurate(climbs) {
    if (climbs.length === 0) return [];
    const merged = [];
    let prev = climbs[0];

    for (let i = 1; i < climbs.length; i++) {
        const curr = climbs[i];
        const gap = curr.startKm - prev.endKm;

        if (gap <= MERGE_MAX_GAP_KM) {
            prev = {
                startKm: prev.startKm,
                endKm: curr.endKm,
                gain: prev.gain + curr.gain,
                avgGrade: ((prev.gain+curr.gain)/((curr.endKm-prev.startKm)*1000))*100
            };
        } else {
            merged.push(prev);
            prev = curr;
        }
    }
    merged.push(prev);
    return merged;
}

// -------------------------
// CANVAS HELPERS
// -------------------------
function createOverlay(id, bottomPx, heightPx, zIndex) {
    let existing = document.getElementById(id);
    if (existing) return existing.querySelector("canvas");

    const overlay = document.createElement("div");
    overlay.id = id;
    overlay.style.position = "fixed";
    overlay.style.bottom = bottomPx + "px";
    overlay.style.left = "50%";
    overlay.style.transform = "translateX(-50%)";
    overlay.style.width = "43vw";
    overlay.style.height = "150px";
    overlay.style.background = "rgba(0,0,0,0.25)";
    overlay.style.zIndex = zIndex;

    const canvas = document.createElement("canvas");
    overlay.appendChild(canvas);
    document.body.appendChild(overlay);

    requestAnimationFrame(() => {
        const r = overlay.getBoundingClientRect();
        canvas.width = r.width;
        canvas.height = r.height;
    });

    return canvas;
}

function densifyPoints(points, factor = 5) {
    const out = [];
    for (let i = 0; i < points.length-1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        out.push(p0);
        for (let j = 1; j < factor; j++) {
            const t = j/factor;
            out.push({
                x: p0.x + (p1.x-p0.x)*t,
                y: p0.y + (p1.y-p0.y)*t
            });
        }
    }
    out.push(points[points.length-1]);
    return out;
}
function filterClimbs(climbs) {
    return climbs.filter(c => c.avgGrade >= MIN_AVG_GRADE && c.gain >= MIN_GAIN_M);
}
// -------------------------
// ACTIVE CLIMB OVERLAY
// -------------------------
function drawActiveClimbOverlay(points, climbs, total_km, myKm) {
    const canvas = createOverlay("activeClimbOverlay", 110, 80, 99999);
    const ctx = canvas.getContext("2d");
    if (!points || !climbs.length || myKm == null) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const EPS = 0.01;
    const activeClimb = climbs.find(c => myKm + EPS >= c.startKm && myKm - EPS <= c.endKm);
    if (!activeClimb) return;

    // --- use actual X/Y from polyline ---
    const minX = points[0].x;
    const maxX = points[points.length-1].x;
    const dist = points.map(p => (p.x - minX) / (maxX - minX) * total_km);
    const elev = points.map(p => (1 - p.y) * total_climb);

    const climbLength = activeClimb.endKm - activeClimb.startKm;
const zoomStartKm = activeClimb.startKm;
const zoomEndKm = activeClimb.endKm;


const kmToX = km => canvas.width * ((km - zoomStartKm)/(zoomEndKm - zoomStartKm));
    const riderKmToX = km => canvas.width * ((km - zoomStartKm) / (zoomEndKm - zoomStartKm));
    const riderX = riderKmToX(myKm);

    const minY = Math.min(...elev);
    const maxY = Math.max(...elev);

    // densify for smooth gradient
    const dense = densifyPoints(points, 5).map(p => ({
        x: (p.x - minX)/(maxX - minX) * total_km,
        y: (1 - p.y) * total_climb
    }));
    const N = dense.length;

    let startIndex = dense.findIndex(p => p.x >= activeClimb.startKm);
    if (startIndex < 0) startIndex = 0;
    let endIndex = dense.findIndex(p => p.x >= activeClimb.endKm);
    if (endIndex < 0) endIndex = N-1;

    // --- draw gradient bars ---
    for (let i = startIndex; i < endIndex; i++) {
        const km0 = dense[i].x;
        const km1 = dense[i+1].x;
        if (km1 < zoomStartKm || km0 > zoomEndKm) continue;

const marginTop = 10;       // 10px margin at top
const marginBottom = 0;    // optional, same at bottom


        const x0 = kmToX(km0);
        const x1 = kmToX(km1);
const fy0 = canvas.height - marginBottom - ((dense[i].y - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));
const fy1 = canvas.height - marginBottom - ((dense[i+1].y - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));

        const dxMeters = (km1 - km0) * 1000;
        const dyMeters = dense[i+1].y - dense[i].y;
        const grade = dxMeters!==0 ? (dyMeters/dxMeters)*100 : 0;

        ctx.fillStyle = gradeToColor(grade);
        ctx.beginPath();
        ctx.moveTo(x0, canvas.height);
        ctx.lineTo(x0, fy0);
        ctx.lineTo(x1, fy1);
        ctx.lineTo(x1, canvas.height);
        ctx.fill();
    }

    // --- rider marker ---
    ctx.strokeStyle="red";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(riderX,0);
    ctx.lineTo(riderX,canvas.height);
    ctx.stroke();

    // --- climb info text ---
    const idx = climbs.indexOf(activeClimb);
    let correctedGain = activeClimb.gain;
    if (window.CONSOLE_CLIMBS && window.CONSOLE_CLIMBS[idx] && Number.isFinite(window.CONSOLE_CLIMBS[idx].gain)) {
        correctedGain = window.CONSOLE_CLIMBS[idx].gain;
    }
    correctedGain = Number(correctedGain) || 0;

    let climbedSoFar = 0;
    for (let i = startIndex; i < endIndex; i++) {
        const km0 = dense[i].x;
        const km1 = dense[i+1].x;
        const dy = dense[i+1].y - dense[i].y;
        if (km1 <= myKm) climbedSoFar += Math.max(0, dy);
        else if (km0 < myKm) climbedSoFar += Math.max(0, dy*(myKm-km0)/(km1-km0));
        else break;
    }
    climbedSoFar = Math.max(0, climbedSoFar);

    const remainingHeight = Math.round(Math.max(0, correctedGain - climbedSoFar));
    const remainingKm = Math.max(0, activeClimb.endKm - myKm);
    const remainingGrade = remainingKm>0 ? (remainingHeight / (remainingKm*1000))*100 : 0;

    // time
    if (!activeClimb.__startTime && myKm >= activeClimb.startKm) activeClimb.__startTime = performance.now();
    const elapsedSec = activeClimb.__startTime ? Math.floor((performance.now()-activeClimb.__startTime)/1000) : 0;
    const elapsedStr = `${Math.floor(elapsedSec/60)}:${String(elapsedSec%60).padStart(2,"0")}`;
    let etaStr="??:??";
    if (window.lastSpeedKph && window.lastSpeedKph>1){
        const sec = (remainingKm*1000)/(window.lastSpeedKph/3.6);
        etaStr = `${Math.floor(sec/60)}:${String(Math.floor(sec%60)).padStart(2,"0")}`;
    }

    ctx.fillStyle="#fff";
    ctx.font="bold 16px Overpass,sans-serif";
    ctx.textAlign="center";
    ctx.fillText(
        `Climb ${idx+1}/${climbs.length} | ${remainingKm.toFixed(2)} km | ${remainingHeight} m | ${remainingGrade.toFixed(1)}%`,
        canvas.width/2,20
    );
    ctx.fillText(
        `ETA: ${etaStr} | Elapsed: ${elapsedStr}`,
        canvas.width/2,40
    );
}

// -------------------------
// SPEED & POSITION
// -------------------------
function updateSpeed() {
    const rows = document.querySelectorAll(".stat-row");
    if (!rows.length) return;
    const el = rows[0].querySelector(".stat-row-split .stat-value");
    if (!el) return;
    const v = parseFloat(el.textContent.replace(",","."));
    if (!isNaN(v)) window.lastSpeedKph = v;
}
setInterval(updateSpeed,500);

function getMyKm() {
    if (total_km==null) return null;
    const rows = document.querySelectorAll(".stat-row");
    if (rows.length<3) return null;
    const el = rows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!el) return null;
    const remaining = parseFloat(el.textContent.replace(",","."));
    if (isNaN(remaining)) return null;
    return Math.max(0, total_km - remaining);
}

// -------------------------
// INIT
// -------------------------
function initOverlays() {
    const stats = extractStats();
    const poly = getPolylinePoints();
    if (!stats || !poly) return false;

    total_km = stats.total_km;
    total_climb = stats.total_climb;
    points = poly;

    climbs = computeClimbsAccurate(points,total_km,total_climb);
    climbs = filterClimbs(climbs);          // <-- filter short/weak climbs

    climbs = mergeCloseClimbsAccurate(climbs);

    window.CONSOLE_CLIMBS = climbs;
    console.log("âœ… Climb table exported to window.CONSOLE_CLIMBS");
    console.table(climbs);

    return true;
}

const initTimer=setInterval(()=>{ if (initOverlays()) clearInterval(initTimer); },500);
setInterval(()=>{
    if (total_km && points && climbs.length)
        drawActiveClimbOverlay(points,climbs,total_km,getMyKm());
},ACTIVE_UPDATE_INTERVAL);

})();
