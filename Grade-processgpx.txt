// ==UserScript==
// @name         Biketerra ClimbPro Feat. DJCONNEL
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  This adds a Climbpro like overlay to Biketerra, almost all functionality was taken from ProcessGPX by DJCONNEL ( https://github.com/djconnel/processGPX ) and everything else was done by mainly chatgpt.
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @icon         https://www.google.com/s2/favicons?sz=64&domain=biketerra.com
// @grant        none
// ==/UserScript==

(function() {
'use strict';

// -------------------------
// PARAMETERS
// -------------------------
const MIN_AVG_GRADE = 1.5;       // accept shallower climbs
const MIN_GAIN_M = 50;           // accept shorter climbs
const MAX_GRADE_DRAW = 15;
const ACTIVE_UPDATE_INTERVAL = 200;

// Recursive-score thresholds
const SCORE_THRESHOLD = 1;           // score = gain^2 / distMeters must exceed this
const GRADIENT_THRESHOLD_METERS = 0;   // optional: require that a 10% gradient must gain at least this many meters (0 disables)

// Color thresholds
const GRADE_COLORS = [
    { grade: -0, color: "#0093fc" },
    { grade: 0, color: "#00FF00" },
    { grade: 3, color: "#FFFF00" },
    { grade: 6, color: "#FFA500" },
    { grade: 9, color: "#FF4500" },
    { grade: 12, color: "#800080" }
];

function gradeToColor(g) {
    for (let i = GRADE_COLORS.length - 1; i >= 0; i--) {
        if (g >= GRADE_COLORS[i].grade) return GRADE_COLORS[i].color;
    }
    return GRADE_COLORS[0].color;
}

// -------------------------
// STATE
// -------------------------
let total_km = null;
let total_climb = null;
let points = null;
let climbs = [];

// -------------------------
// HELPERS (DOM / polyline)
// -------------------------
function extractStats() {
    const statRows = document.querySelectorAll(".stat-row");
    if (statRows.length < 4) return null;

    const distEl = statRows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!distEl || !climbEl) return null;

    return {
        total_km: parseFloat(distEl.textContent.trim().replace(",", ".").replace(" km", "")),
        total_climb: parseFloat(climbEl.textContent.trim().replace(",", "."))
    };
}

function getPolylinePoints() {
    const polyline = document.querySelector('polyline[stroke-width="2"]');
    if (!polyline) return null;

    return polyline.getAttribute("points").trim().split(/\s+/).map(p => {
        const [x, y] = p.split(",").map(parseFloat);
        return { x, y };
    });
}

// -------------------------
// RECURSIVE BEST-CLIMB FINDER
// -------------------------
// We'll implement findBestClimbsInRange using prefix sums for positive deltas.
// Input: points array, total_km, total_climb
// Output: array of climbs { startIdx, endIdx, startKm, endKm, gain, avgGrade }

function computeClimbsByUphillSegments(points, total_km, total_climb) {
    if (!points || points.length < 2) return [];

    const N = points.length;
    const minX = points[0].x;
    const maxX = points[N - 1].x;

    const distKm = points.map(p => ((p.x - minX) / (maxX - minX)) * total_km);
    const elevNorm = points.map(p => 1 - p.y);

    // scale positive-only to match total climb
    let posSum = 0;
    for (let i = 1; i < N; i++) {
        const d = elevNorm[i] - elevNorm[i - 1];
        if (d > 0) posSum += d;
    }
    const scale = posSum > 0 ? (total_climb / posSum) : 0;
    const elevMeters = elevNorm.map(v => v * scale);

    const climbs = [];
    let startIdx = null;
    for (let i = 1; i < N; i++) {
        const dy = elevMeters[i] - elevMeters[i - 1];
        const dx = (distKm[i] - distKm[i - 1]) * 1000;
        const grade = dx !== 0 ? (dy / dx) * 100 : 0;

        // consider tiny downhill as part of climb
        const uphillTolerance = -1; // percent grade
        if (grade >= uphillTolerance) {
            if (startIdx === null) startIdx = i - 1;
        } else {
            if (startIdx !== null) {
                // end climb here
                const endIdx = i - 1;
                const gain = Math.max(0, elevMeters[endIdx] - elevMeters[startIdx]);
                const distM = (distKm[endIdx] - distKm[startIdx]) * 1000;
                const avgGrade = distM > 0 ? (gain / distM) * 100 : 0;
                if (gain >= MIN_GAIN_M && avgGrade >= MIN_AVG_GRADE) {
                    climbs.push({
                        startIdx,
                        endIdx,
                        startKm: distKm[startIdx],
                        endKm: distKm[endIdx],
                        gain: Math.round(gain),
                        avgGrade: Number(avgGrade.toFixed(1))
                    });
                }
                startIdx = null;
            }
        }
    }

    // handle last segment
    if (startIdx !== null) {
        const endIdx = N - 1;
        const gain = Math.max(0, elevMeters[endIdx] - elevMeters[startIdx]);
        const distM = (distKm[endIdx] - distKm[startIdx]) * 1000;
        const avgGrade = distM > 0 ? (gain / distM) * 100 : 0;
        if (gain >= MIN_GAIN_M && avgGrade >= MIN_AVG_GRADE) {
            climbs.push({
                startIdx,
                endIdx,
                startKm: distKm[startIdx],
                endKm: distKm[endIdx],
                gain: Math.round(gain),
                avgGrade: Number(avgGrade.toFixed(1))
            });
        }
    }

    console.log("Segmented climbs found:", climbs.length, climbs);
    return climbs;
}

// -------------------------
// Canvas helpers & drawing (kept largely the same as you used)
// -------------------------
function createOverlay(id, bottomPx, heightPx, zIndex) {
    let existing = document.getElementById(id);
    if (existing) return existing.querySelector("canvas");

    const overlay = document.createElement("div");
    overlay.id = id;
    overlay.style.position = "fixed";
    overlay.style.bottom = bottomPx + "px";
    overlay.style.left = "50%";
    overlay.style.transform = "translateX(-50%)";
    overlay.style.width = "43vw";
    overlay.style.height = heightPx + "px";
    overlay.style.background = "rgba(0,0,0,0.50)";
    overlay.style.borderRadius = "5px"; // or whatever looks good
    overlay.style.overflow = "hidden";   // ensures background/gradients respect the rounding

    overlay.style.zIndex = zIndex;

    const canvas = document.createElement("canvas");
    overlay.appendChild(canvas);
    document.body.appendChild(overlay);

    requestAnimationFrame(() => {
        const r = overlay.getBoundingClientRect();
        canvas.width = r.width;
        canvas.height = r.height;
    });

    return canvas;
}

function densifyPoints(points, factor = 5) {
    const out = [];
    for (let i = 0; i < points.length-1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        out.push(p0);
        for (let j = 1; j < factor; j++) {
            const t = j/factor;
            out.push({
                x: p0.x + (p1.x-p0.x)*t,
                y: p0.y + (p1.y-p0.y)*t
            });
        }
    }
    out.push(points[points.length-1]);
    return out;
}

// Active climb overlay â€” draws gradient bars and rider marker, uses console-corrected gains for remaining height calculations
function drawActiveClimbOverlay(pointsArr, climbsArr, total_km_val, myKm) {
    const canvas = createOverlay("activeClimbOverlay", 110, 80, 99999);
    const ctx = canvas.getContext("2d");
    if (!pointsArr || !climbsArr.length || myKm == null) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const EPS = 0.01;
    const activeClimb = climbsArr.find(c => myKm + EPS >= c.startKm && myKm - EPS <= c.endKm);
    if (!activeClimb) return;

    // Map original point X->km and y->meters (same logic used in detection)
    const N = pointsArr.length;
    const minX = pointsArr[0].x;
    const maxX = pointsArr[N - 1].x;
    const distKm = pointsArr.map(p => ((p.x - minX)/(maxX - minX)) * total_km_val);
    // Normalized elev & scaled to meters (positive scaling)
    const elevNorm = pointsArr.map(p => 1 - p.y);
    let posSum = 0;
    for (let i = 1; i < elevNorm.length; i++) {
        const d = elevNorm[i] - elevNorm[i-1];
        if (d > 0) posSum += d;
    }
    const scale = posSum > 0 ? total_climb / posSum : 0;
    const elevMeters = elevNorm.map(v => v * scale);

    const zoomStartKm = activeClimb.startKm;
    const zoomEndKm = activeClimb.endKm;

    const kmToX = km => {
        // Map zoomStart..zoomEnd -> 0..canvas.width
        if (zoomEndKm === zoomStartKm) return canvas.width * 0.5;
        return canvas.width * ((km - zoomStartKm) / (zoomEndKm - zoomStartKm));
    };
    const riderX = kmToX(myKm);

    // Prepare densified, mapped array with km/y(meters)
    const dense = densifyPoints(pointsArr, 5).map(p => ({
        xKm: ((p.x - minX)/(maxX - minX)) * total_km_val,
        yMeters: (1 - p.y) * scale
    }));
    const M = dense.length;

    // compute min/max y within the whole route or ideally only around climb for better scale:
    let minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < dense.length; i++) {
        if (dense[i].yMeters < minY) minY = dense[i].yMeters;
        if (dense[i].yMeters > maxY) maxY = dense[i].yMeters;
    }
    // clamp to avoid zero range
    if (minY === maxY) { maxY = minY + 1; }

    // draw bars
    const marginTop = 10;
    const marginBottom = 0;
    for (let i = 0; i < M-1; i++) {
        const km0 = dense[i].xKm;
        const km1 = dense[i+1].xKm;
        if (km1 < zoomStartKm || km0 > zoomEndKm) continue;

        const x0 = kmToX(Math.max(km0, zoomStartKm));
        const x1 = kmToX(Math.min(km1, zoomEndKm));

        const fy0 = canvas.height - marginBottom - ((dense[i].yMeters - minY)/(maxY - minY) * (canvas.height - marginTop - marginBottom));
        const fy1 = canvas.height - marginBottom - ((dense[i+1].yMeters - minY)/(maxY - minY) * (canvas.height - marginTop - marginBottom));

        const dxMeters = (km1 - km0) * 1000;
        const dyMeters = (dense[i+1].yMeters - dense[i].yMeters);
        const grade = dxMeters !== 0 ? (dyMeters / dxMeters) * 100 : 0;

        ctx.fillStyle = gradeToColor(grade);
        ctx.beginPath();
        ctx.moveTo(x0, canvas.height);
        ctx.lineTo(x0, fy0);
        ctx.lineTo(x1, fy1);
        ctx.lineTo(x1, canvas.height);
        ctx.closePath();
        ctx.fill();
    }

    // rider marker (vertical line left->right)
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(riderX, 0);
    ctx.lineTo(riderX, canvas.height);
    ctx.stroke();

    // --- climb info text (use corrected gain from console export if available) ---
    const idx = climbsArr.indexOf(activeClimb);
    let correctedGain = activeClimb.gain;
    if (window.CONSOLE_CLIMBS && window.CONSOLE_CLIMBS[idx] && Number.isFinite(window.CONSOLE_CLIMBS[idx].gain)) {
        correctedGain = window.CONSOLE_CLIMBS[idx].gain;
    }
    correctedGain = Number(correctedGain) || 0;

    // compute climbedSoFar using dense points and partial segment interpolation
    let climbedSoFar = 0;
    for (let i = 0; i < M-1; i++) {
        const km0 = dense[i].xKm;
        const km1 = dense[i+1].xKm;
        if (km1 <= activeClimb.startKm) continue;      // before climb
        if (km0 >= activeClimb.endKm) break;           // after climb
        // clamp segment to climb window
        const segStartKm = Math.max(km0, activeClimb.startKm);
        const segEndKm = Math.min(km1, activeClimb.endKm);
        if (segEndKm <= segStartKm) continue;
        // consider only portion <= myKm (climbed part)
        const segClimbedEndKm = Math.min(segEndKm, myKm);
        if (segClimbedEndKm <= segStartKm) continue;
        const fracWhole = (segEndKm - segStartKm) > 0 ? (segClimbedEndKm - segStartKm) / (segEndKm - segStartKm) : 0;
        // dy for entire segment (in meters)
        const segDy = dense[i+1].yMeters - dense[i].yMeters;
        // positive uphill contribution for the climbed portion:
        const climbedDy = Math.max(0, segDy * fracWhole);
        climbedSoFar += climbedDy;
    }
    climbedSoFar = Math.max(0, climbedSoFar);

    const remainingHeight = Math.round(Math.max(0, correctedGain - climbedSoFar));
    const remainingKm = Math.max(0, activeClimb.endKm - myKm);
    const remainingGrade = remainingKm > 0 ? (remainingHeight / (remainingKm * 1000)) * 100 : 0;

    // time calculations
    if (!activeClimb.__startTime && myKm >= activeClimb.startKm) activeClimb.__startTime = performance.now();
    const elapsedSec = activeClimb.__startTime ? Math.floor((performance.now() - activeClimb.__startTime) / 1000) : 0;
    const elapsedStr = `${Math.floor(elapsedSec / 60)}:${String(elapsedSec % 60).padStart(2, "0")}`;
    let etaStr = "??:??";
    if (window.lastSpeedKph && window.lastSpeedKph > 1) {
        const sec = (remainingKm * 1000) / (window.lastSpeedKph / 3.6);
        etaStr = `${Math.floor(sec / 60)}:${String(Math.floor(sec % 60)).padStart(2, "0")}`;
    }

    // draw text
    ctx.fillStyle = "#fff";
ctx.font = "bold 16px Overpass, sans-serif";
ctx.textAlign = "center";

// Text 1: Climb info
ctx.fillStyle = "#fff";           // white fill
ctx.strokeStyle = "#000";         // black outline
ctx.lineWidth = 1.5;                // 1px outline

ctx.strokeText(
    `Climb ${idx + 1}/${climbsArr.length} | ${remainingKm.toFixed(2)} km | ${remainingHeight} m | ${remainingGrade.toFixed(1)}%`,
    canvas.width / 2, 20
);
ctx.fillText(
    `Climb ${idx + 1}/${climbsArr.length} | ${remainingKm.toFixed(2)} km | ${remainingHeight} m | ${remainingGrade.toFixed(1)}%`,
    canvas.width / 2, 20
);

// Text 2: ETA info
ctx.strokeText(
    `ETA: ${etaStr} | Elapsed: ${elapsedStr}`,
    canvas.width / 2, 40
);
ctx.fillText(
    `ETA: ${etaStr} | Elapsed: ${elapsedStr}`,
    canvas.width / 2, 40
);
}
function extendClimbsInclusive(climbs, points, minLeadInGrade = 0.1) {
    // minLeadInGrade = minimal slope considered as part of climb
    return climbs.map(climb => {
        let start = climb.startIdx;
        let end = climb.endIdx;

        // extend backwards: include tiny uphill / low-grade lead-in
        while (start > 0) {
            const dy = points[start].y - points[start - 1].y;
            const dx = points[start].x - points[start - 1].x;
            const grad = dy / dx; // slope fraction
            if (grad < -0.01) break; // allow tiny downhill, stop if steep downhill
            if (grad < minLeadInGrade) start--; // include low slope
            else start--;
        }

        // extend forwards (same as before)
        while (end < points.length - 1) {
            const dy = points[end + 1].y - points[end].y;
            const dx = points[end + 1].x - points[end].x;
            const grad = dy / dx;
            if (grad < -0.01) break;
            end++;
        }

        return {
            ...climb,
            startIdx: start,
            endIdx: end
        };
    });
}


// -------------------------
// Speed & MyKm helpers (same as before)
// -------------------------
function updateSpeed() {
    const rows = document.querySelectorAll(".stat-row");
    if (!rows.length) return;
    const el = rows[0].querySelector(".stat-row-split .stat-value");
    if (!el) return;
    const v = parseFloat(el.textContent.replace(",", "."));
    if (!isNaN(v)) window.lastSpeedKph = v;
}
setInterval(updateSpeed, 500);

function getMyKm() {
    if (total_km == null) return null;
    const rows = document.querySelectorAll(".stat-row");
    if (rows.length < 3) return null;
    const el = rows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!el) return null;
    const remaining = parseFloat(el.textContent.replace(",", "."));
    if (isNaN(remaining)) return null;
    return Math.max(0, total_km - remaining);
}
function moveBottomPanelUp(overlayHeight = 200) {
    const panel = document.querySelector(".panel-bottom-center");
    if (!panel) return;

    // Only apply once
    if (!panel.dataset.moved) {
        const rect = panel.getBoundingClientRect();

        panel.style.position = "fixed"; // fixed relative to viewport
        panel.style.bottom = overlayHeight + "px"; // move above overlay
        panel.style.left = "50%";
        panel.style.transform = "translateX(-50%)";
        panel.style.zIndex = 999999; // above most things

        panel.dataset.moved = "true";
    }
}

// Keep checking in case the panel is re-rendered by the site
setInterval(() => {
    moveBottomPanelUp(200); // 250px above bottom
}, 200);


// -------------------------
// Init & main loop
// -------------------------
function initOverlays() {
    const stats = extractStats();
    const poly = getPolylinePoints();
    if (!stats || !poly) return false;

    total_km = stats.total_km;
    total_climb = stats.total_climb;
    points = poly;

    // 1) Compute climbs recursively
    let rawClimbs = computeClimbsByUphillSegments(points, total_km, total_climb);

    // 2) Optional basic filtering
    rawClimbs = rawClimbs.filter(c => c.avgGrade >= MIN_AVG_GRADE && c.gain >= MIN_GAIN_M);

    // 3) Extend climbs to include gentle slopes before/after
climbs = extendClimbsInclusive(rawClimbs, points, 0.1);

    // 4) Export to console
    window.CONSOLE_CLIMBS = climbs;
    console.log("âœ… Climb table exported to window.CONSOLE_CLIMBS");
    console.table(climbs);

    return true;
}
// -------------------------
// AUTO REFRESH ON NEW RIDE
// -------------------------
// -------------------------
// AUTO REFRESH ON NEW RIDE (persistent)
// -------------------------
let lastClimbValue = null;

function watchTotalClimbPersistent() {
    const checkInterval = 500; // ms
    setInterval(() => {
        const statRows = document.querySelectorAll(".stat-row");
        if (statRows.length < 4) return;

        const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
        if (!climbEl) return;

        const newVal = parseFloat(climbEl.textContent.replace(",", "."));
        if (!Number.isFinite(newVal)) return;

        if (lastClimbValue === 0 && newVal > 0) {
            console.log("ðŸ”„ Detected new ride, reinitializing overlays...");
            initOverlays(); // re-run your overlay init
        }

        lastClimbValue = newVal;
    }, checkInterval);
}

// Start persistent watch
watchTotalClimbPersistent();


const initTimer = setInterval(() => { if (initOverlays()) clearInterval(initTimer); }, 500);

setInterval(() => {
    if (total_km && points && climbs.length) {
        //console.log("climbs detected:", climbs.length, climbs);

        drawActiveClimbOverlay(points, climbs, total_km, getMyKm());
    }
}, ACTIVE_UPDATE_INTERVAL);

})(); // end userscript
