// ==UserScript==
// @name         Biketerra ClimbPro Feat. DJCONNEL
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  This adds a Climbpro like overlay to Biketerra, almost all functionality was taken from ProcessGPX by DJCONNEL ( https://github.com/djconnel/processGPX ) and everything else was done by mainly chatgpt.
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @icon         https://www.google.com/s2/favicons?sz=64&domain=biketerra.com
// @grant        none
// ==/UserScript==

(function() {
'use strict';

// -------------------------
// PARAMETERS
// -------------------------
const MIN_AVG_GRADE = 1.5;       // accept shallower climbs
const MIN_GAIN_M = 50;           // accept shorter climbs
const MAX_GRADE_DRAW = 15;
const ACTIVE_UPDATE_INTERVAL = 200;

// Recursive-score thresholds
const SCORE_THRESHOLD = 1;           // score = gain^2 / distMeters must exceed this
const GRADIENT_THRESHOLD_METERS = 0;   // optional: require that a 10% gradient must gain at least this many meters (0 disables)

// Color thresholds
const GRADE_COLORS = [
    { grade: -0, color: "#0093fc" },
    { grade: 0, color: "#00FF00" },
    { grade: 3, color: "#FFFF00" },
    { grade: 6, color: "#FFA500" },
    { grade: 9, color: "#FF4500" },
    { grade: 12, color: "#800080" }
];

function gradeToColor(g) {
    for (let i = GRADE_COLORS.length - 1; i >= 0; i--) {
        if (g >= GRADE_COLORS[i].grade) return GRADE_COLORS[i].color;
    }
    return GRADE_COLORS[0].color;
}

// -------------------------
// STATE
// -------------------------
let total_km = null;
let total_climb = null;
let points = null;
let climbs = [];

// -------------------------
// HELPERS (DOM / polyline)
// -------------------------
function extractStats() {
    const statRows = document.querySelectorAll(".stat-row");
    if (statRows.length < 4) return null;

    const distEl = statRows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!distEl || !climbEl) return null;

    return {
        total_km: parseFloat(distEl.textContent.trim().replace(",", ".").replace(" km", "")),
        total_climb: parseFloat(climbEl.textContent.trim().replace(",", "."))
    };
}

function getPolylinePoints() {
    const polyline = document.querySelector('polyline[stroke-width="2"]');
    if (!polyline) return null;

    return polyline.getAttribute("points").trim().split(/\s+/).map(p => {
        const [x, y] = p.split(",").map(parseFloat);
        return { x, y };
    });
}

// -------------------------
// RECURSIVE BEST-CLIMB FINDER
// -------------------------
// We'll implement findBestClimbsInRange using prefix sums for positive deltas.
// Input: points array, total_km, total_climb
// Output: array of climbs { startIdx, endIdx, startKm, endKm, gain, avgGrade }

function computeClimbsByUphillSegments(points, total_km, total_climb) {
    if (!points || points.length < 2) return [];

    const N = points.length;
    const minX = points[0].x;
    const maxX = points[N - 1].x;

    const distKm = points.map(p => ((p.x - minX) / (maxX - minX)) * total_km);
    const elevNorm = points.map(p => 1 - p.y);

    // scale positive-only to match total climb
    let posSum = 0;
    for (let i = 1; i < N; i++) {
        const d = elevNorm[i] - elevNorm[i - 1];
        if (d > 0) posSum += d;
    }
    const scale = posSum > 0 ? (total_climb / posSum) : 0;
    const elevMeters = elevNorm.map(v => v * scale);

    const climbs = [];
    let startIdx = null;
    for (let i = 1; i < N; i++) {
        const dy = elevMeters[i] - elevMeters[i - 1];
        const dx = (distKm[i] - distKm[i - 1]) * 1000;
        const grade = dx !== 0 ? (dy / dx) * 100 : 0;

        // consider tiny downhill as part of climb
        const uphillTolerance = -1; // percent grade
        if (grade >= uphillTolerance) {
            if (startIdx === null) startIdx = i - 1;
        } else {
            if (startIdx !== null) {
                // end climb here
                const endIdx = i - 1;
                const gain = Math.max(0, elevMeters[endIdx] - elevMeters[startIdx]);
                const distM = (distKm[endIdx] - distKm[startIdx]) * 1000;
                const avgGrade = distM > 0 ? (gain / distM) * 100 : 0;
                if (gain >= MIN_GAIN_M && avgGrade >= MIN_AVG_GRADE) {
                    climbs.push({
                        startIdx,
                        endIdx,
                        startKm: distKm[startIdx],
                        endKm: distKm[endIdx],
                        gain: Math.round(gain),
                        avgGrade: Number(avgGrade.toFixed(1))
                    });
                }
                startIdx = null;
            }
        }
    }

    // handle last segment
    if (startIdx !== null) {
        const endIdx = N - 1;
        const gain = Math.max(0, elevMeters[endIdx] - elevMeters[startIdx]);
        const distM = (distKm[endIdx] - distKm[startIdx]) * 1000;
        const avgGrade = distM > 0 ? (gain / distM) * 100 : 0;
        if (gain >= MIN_GAIN_M && avgGrade >= MIN_AVG_GRADE) {
            climbs.push({
                startIdx,
                endIdx,
                startKm: distKm[startIdx],
                endKm: distKm[endIdx],
                gain: Math.round(gain),
                avgGrade: Number(avgGrade.toFixed(1))
            });
        }
    }

    console.log("Segmented climbs found:", climbs.length, climbs);
    return climbs;
}
function mergeNearbyClimbs(climbs, maxGapMeters = 50) {
    if (!climbs || climbs.length < 2) return climbs;

    const merged = [];
    let current = { ...climbs[0] };

    for (let i = 1; i < climbs.length; i++) {
        const gapKm = climbs[i].startKm - current.endKm;
        const gapMeters = gapKm * 1000;

        if (gapMeters <= maxGapMeters) {
            // merge: extend end, add gains
            current.endIdx = climbs[i].endIdx;
            current.endKm = climbs[i].endKm;
            current.gain += climbs[i].gain;
            current.avgGrade = (current.gain / ((current.endKm - current.startKm) * 1000)) * 100;
        } else {
            merged.push(current);
            current = { ...climbs[i] };
        }
    }

    merged.push(current);
    return merged;
}
// -------------------------
// Canvas helpers & drawing (kept largely the same as you used)
// -------------------------
function createOverlay(id, bottomPx, heightPx, zIndex) {
    let existing = document.getElementById(id);
    if (existing) return existing.querySelector("canvas");

    const overlay = document.createElement("div");
    overlay.id = id;
    overlay.style.position = "fixed";
    overlay.style.bottom = bottomPx + "px";
    overlay.style.left = "50%";
    overlay.style.transform = "translateX(-50%)";
    overlay.style.width = "43vw";
    overlay.style.height = heightPx + "px";
    overlay.style.background = "rgba(0,0,0,0.50)";
    overlay.style.borderRadius = "5px"; // or whatever looks good
    overlay.style.overflow = "hidden";   // ensures background/gradients respect the rounding

    overlay.style.zIndex = zIndex;

    const canvas = document.createElement("canvas");
    overlay.appendChild(canvas);
    document.body.appendChild(overlay);

    requestAnimationFrame(() => {
        const r = overlay.getBoundingClientRect();
        canvas.width = r.width;
        canvas.height = r.height;
    });

    return canvas;
}

function densifyPoints(points, factor = 5) {
    const out = [];
    for (let i = 0; i < points.length-1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        out.push(p0);
        for (let j = 1; j < factor; j++) {
            const t = j/factor;
            out.push({
                x: p0.x + (p1.x-p0.x)*t,
                y: p0.y + (p1.y-p0.y)*t
            });
        }
    }
    out.push(points[points.length-1]);
    return out;
}

// Active climb overlay â€” draws gradient bars and rider marker, uses console-corrected gains for remaining height calculations
function drawActiveClimbOverlay(pointsArr, climbsArr, total_km_val, myKm) {
    const canvas = createOverlay("activeClimbOverlay", 110, 80, 99999);
    const ctx = canvas.getContext("2d");
    if (!pointsArr || !climbsArr.length || myKm == null) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const EPS = 0.01;
    let activeClimb = climbsArr.find(c => myKm + EPS >= c.startKm && myKm - EPS <= c.endKm);

    // Keep finished climb summary in same active overlay
    if (!window.__climbSummary) window.__climbSummary = null;

    // If a climb just finished recently, show its summary for 10 s
    if (window.__climbSummary && performance.now() - window.__climbSummary.time < 10000) {
        const s = window.__climbSummary;
        const elapsedStr = `${Math.floor(s.duration/60)}:${String(Math.floor(s.duration%60)).padStart(2,"0")}`;

        ctx.fillStyle = "#000a"; // dimmed background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.font = "bold 18px Overpass, sans-serif";
        ctx.fillText(`âœ… Climb ${s.index + 1} finished!`, canvas.width / 2, 30);

        ctx.font = "16px Overpass, sans-serif";
        ctx.fillText(`Height: ${s.gain} m | Avg: ${s.avgGrade.toFixed(1)}%`, canvas.width / 2, 55);
        ctx.fillText(`Time: ${elapsedStr}`, canvas.width / 2, 75);
        return;
    }

    const N = pointsArr.length;
    const minX = pointsArr[0].x, maxX = pointsArr[N - 1].x;
    const distKm = pointsArr.map(p => ((p.x - minX) / (maxX - minX)) * total_km_val);
    const elevNorm = pointsArr.map(p => 1 - p.y);
    let posSum = 0;
    for (let i = 1; i < elevNorm.length; i++) {
        const d = elevNorm[i] - elevNorm[i - 1];
        if (d > 0) posSum += d;
    }
    const scale = posSum > 0 ? total_climb / posSum : 0;
    const dense = densifyPoints(pointsArr, 5).map(p => ({
        xKm: ((p.x - minX) / (maxX - minX)) * total_km_val,
        yMeters: (1 - p.y) * scale
    }));
    const M = dense.length;

    if (activeClimb) {
        const zoomStartKm = activeClimb.startKm;
        const zoomEndKm = activeClimb.endKm;
        const kmToX = km => (zoomEndKm === zoomStartKm)
            ? canvas.width * 0.5
            : canvas.width * ((km - zoomStartKm) / (zoomEndKm - zoomStartKm));
        const riderX = kmToX(myKm);

        let minY = Infinity, maxY = -Infinity;
        for (let i = 0; i < M; i++) {
            if (dense[i].yMeters < minY) minY = dense[i].yMeters;
            if (dense[i].yMeters > maxY) maxY = dense[i].yMeters;
        }
        if (minY === maxY) maxY = minY + 1;

        const marginTop = 10, marginBottom = 5;
        for (let i = 0; i < M - 1; i++) {
            const km0 = dense[i].xKm, km1 = dense[i + 1].xKm;
            if (km1 < zoomStartKm || km0 > zoomEndKm) continue;
            const x0 = kmToX(Math.max(km0, zoomStartKm));
            const x1 = kmToX(Math.min(km1, zoomEndKm));
            const fy0 = canvas.height - marginBottom - ((dense[i].yMeters - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));
            const fy1 = canvas.height - marginBottom - ((dense[i + 1].yMeters - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));
            const dxMeters = (km1 - km0) * 1000;
            const dyMeters = (dense[i + 1].yMeters - dense[i].yMeters);
            const grade = dxMeters !== 0 ? (dyMeters / dxMeters) * 100 : 0;
            ctx.fillStyle = gradeToColor(grade);
            ctx.beginPath();
            ctx.moveTo(x0, canvas.height);
            ctx.lineTo(x0, fy0);
            ctx.lineTo(x1, fy1);
            ctx.lineTo(x1, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        // Rider marker
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(riderX, 0);
        ctx.lineTo(riderX, canvas.height);
        ctx.stroke();

        // Timing + finish detection
        const idx = climbsArr.indexOf(activeClimb);
        if (!activeClimb.__startTime && myKm >= activeClimb.startKm)
            activeClimb.__startTime = performance.now();

        if (myKm > activeClimb.endKm + 0.005 && activeClimb.__startTime && !activeClimb.__finished) {
            activeClimb.__finished = true;
            const duration = (performance.now() - activeClimb.__startTime) / 1000;
            window.__climbSummary = {
                index: idx,
                gain: activeClimb.gain,
                avgGrade: activeClimb.avgGrade,
                duration,
                time: performance.now()
            };
            return;
        }

        // Display climb info
        const remainingKm = Math.max(0, activeClimb.endKm - myKm);
        const remainingHeight = activeClimb.gain * (remainingKm / (activeClimb.endKm - activeClimb.startKm));
        const remainingGrade = remainingKm > 0 ? (remainingHeight / (remainingKm * 1000)) * 100 : 0;
        const elapsedSec = activeClimb.__startTime ? Math.floor((performance.now() - activeClimb.__startTime) / 1000) : 0;
        const elapsedStr = `${Math.floor(elapsedSec / 60)}:${String(elapsedSec % 60).padStart(2, "0")}`;

        let etaStr = "??:??";
        if (window.lastSpeedKph && window.lastSpeedKph > 1) {
            const sec = (remainingKm * 1000) / (window.lastSpeedKph / 3.6);
            etaStr = `${Math.floor(sec / 60)}:${String(Math.floor(sec % 60)).padStart(2, "0")}`;
        }

        ctx.fillStyle = "#fff";
        ctx.font = "bold 16px Overpass, sans-serif";
        ctx.textAlign = "center";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.strokeText(`Climb ${idx + 1}/${climbsArr.length} | ${remainingKm.toFixed(2)} km | ${remainingHeight.toFixed(0)} m | ${remainingGrade.toFixed(1)}%`, canvas.width / 2, 20);
        ctx.fillText(`Climb ${idx + 1}/${climbsArr.length} | ${remainingKm.toFixed(2)} km | ${remainingHeight.toFixed(0)} m | ${remainingGrade.toFixed(1)}%`, canvas.width / 2, 20);
        ctx.strokeText(`ETA: ${etaStr} | Elapsed: ${elapsedStr}`, canvas.width / 2, 40);
        ctx.fillText(`ETA: ${etaStr} | Elapsed: ${elapsedStr}`, canvas.width / 2, 40);
    } else {
        // No active climb â€” preview next or say none
        const nextClimb = climbsArr.find(c => c.startKm > myKm);
        if (!nextClimb) {
            ctx.fillStyle = "#fff";
            ctx.font = "bold 18px Overpass, sans-serif";
            ctx.textAlign = "center";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1.5;
            ctx.strokeText("No more climbs!", canvas.width / 2, 40);
            ctx.fillText("No more climbs!", canvas.width / 2, 40);
            return;
        }

        const distanceToNext = nextClimb.startKm - myKm;
        const zoomStartKm = nextClimb.startKm, zoomEndKm = nextClimb.endKm;
        const kmToX = km => (zoomEndKm === zoomStartKm)
            ? canvas.width * 0.5
            : canvas.width * ((km - zoomStartKm) / (zoomEndKm - zoomStartKm));

        let minY = Infinity, maxY = -Infinity;
        for (let i = 0; i < M; i++) {
            const km = dense[i].xKm;
            if (km < zoomStartKm || km > zoomEndKm) continue;
            if (dense[i].yMeters < minY) minY = dense[i].yMeters;
            if (dense[i].yMeters > maxY) maxY = dense[i].yMeters;
        }
        if (minY === maxY) maxY = minY + 1;

        const marginTop = 10, marginBottom = 5;
        for (let i = 0; i < M - 1; i++) {
            const km0 = dense[i].xKm, km1 = dense[i + 1].xKm;
            if (km1 < zoomStartKm || km0 > zoomEndKm) continue;
            const x0 = kmToX(Math.max(km0, zoomStartKm));
            const x1 = kmToX(Math.min(km1, zoomEndKm));
            const fy0 = canvas.height - marginBottom - ((dense[i].yMeters - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));
            const fy1 = canvas.height - marginBottom - ((dense[i + 1].yMeters - minY) / (maxY - minY) * (canvas.height - marginTop - marginBottom));
            const dxMeters = (km1 - km0) * 1000;
            const dyMeters = (dense[i + 1].yMeters - dense[i].yMeters);
            const grade = dxMeters !== 0 ? (dyMeters / dxMeters) * 100 : 0;
            ctx.fillStyle = gradeToColor(grade);
            ctx.beginPath();
            ctx.moveTo(x0, canvas.height);
            ctx.lineTo(x0, fy0);
            ctx.lineTo(x1, fy1);
            ctx.lineTo(x1, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        ctx.fillStyle = "#fff";
        ctx.font = "bold 16px Overpass, sans-serif";
        ctx.textAlign = "center";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.strokeText(`Next climb in ${distanceToNext.toFixed(2)} km | ${nextClimb.gain} m | ${nextClimb.avgGrade.toFixed(1)}%`, canvas.width / 2, 20);
        ctx.fillText(`Next climb in ${distanceToNext.toFixed(2)} km | ${nextClimb.gain} m | ${nextClimb.avgGrade.toFixed(1)}%`, canvas.width / 2, 20);
    }
}

    function extendClimbsInclusive(climbs, points, minLeadInGrade = 0.1) {
    // minLeadInGrade = minimal slope considered as part of climb
    return climbs.map(climb => {
        let start = climb.startIdx;
        let end = climb.endIdx;

        // extend backwards: include tiny uphill / low-grade lead-in
        while (start > 0) {
            const dy = points[start].y - points[start - 1].y;
            const dx = points[start].x - points[start - 1].x;
            const grad = dy / dx; // slope fraction
            if (grad < -0.01) break; // allow tiny downhill, stop if steep downhill
            if (grad < minLeadInGrade) start--; // include low slope
            else start--;
        }

        // extend forwards (same as before)
        while (end < points.length - 1) {
            const dy = points[end + 1].y - points[end].y;
            const dx = points[end + 1].x - points[end].x;
            const grad = dy / dx;
            if (grad < -0.01) break;
            end++;
        }

        return {
            ...climb,
            startIdx: start,
            endIdx: end
        };
    });
}


// -------------------------
// Speed & MyKm helpers (same as before)
// -------------------------
function updateSpeed() {
    const rows = document.querySelectorAll(".stat-row");
    if (!rows.length) return;
    const el = rows[0].querySelector(".stat-row-split .stat-value");
    if (!el) return;
    const v = parseFloat(el.textContent.replace(",", "."));
    if (!isNaN(v)) window.lastSpeedKph = v;
}
setInterval(updateSpeed, 500);

function getMyKm() {
    if (total_km == null) return null;
    const rows = document.querySelectorAll(".stat-row");
    if (rows.length < 3) return null;
    const el = rows[2].querySelector(".stat-row-split.stat-avg .avg-value");
    if (!el) return null;
    const remaining = parseFloat(el.textContent.replace(",", "."));
    if (isNaN(remaining)) return null;
    return Math.max(0, total_km - remaining);
}
function moveBottomPanelUp(overlayHeight = 200) {
    const panel = document.querySelector(".panel-bottom-center");
    if (!panel) return;

    // Only apply once
    if (!panel.dataset.moved) {
        const rect = panel.getBoundingClientRect();

        panel.style.position = "fixed"; // fixed relative to viewport
        panel.style.bottom = overlayHeight + "px"; // move above overlay
        panel.style.left = "50%";
        panel.style.transform = "translateX(-50%)";
        panel.style.zIndex = 999999; // above most things

        panel.dataset.moved = "true";
    }
}

// Keep checking in case the panel is re-rendered by the site
setInterval(() => {
    moveBottomPanelUp(200); // 250px above bottom
}, 200);


// -------------------------
// Init & main loop
// -------------------------
function initOverlays() {
    const stats = extractStats();
    const poly = getPolylinePoints();
    if (!stats || !poly) return false;

    total_km = stats.total_km;
    total_climb = stats.total_climb;
    points = poly;

   let rawClimbs = computeClimbsByUphillSegments(points, total_km, total_climb);
rawClimbs = rawClimbs.filter(c => c.avgGrade >= MIN_AVG_GRADE && c.gain >= MIN_GAIN_M);
rawClimbs = extendClimbsInclusive(rawClimbs, points, 0.1);

// MERGE nearby climbs
rawClimbs = mergeNearbyClimbs(rawClimbs, 200); // 50 meters max gap
climbs = rawClimbs;

    // 4) Export to console
    window.CONSOLE_CLIMBS = climbs;
    console.log("âœ… Climb table exported to window.CONSOLE_CLIMBS");
    console.table(climbs);

    return true;
}
// -------------------------
// AUTO REFRESH ON NEW RIDE
// -------------------------
// -------------------------
// AUTO REFRESH ON NEW RIDE (persistent)
// -------------------------
let lastClimbValue = null;

function watchTotalClimbPersistent() {
    const checkInterval = 500; // ms
    setInterval(() => {
        const statRows = document.querySelectorAll(".stat-row");
        if (statRows.length < 4) return;

        const climbEl = statRows[3].querySelector(".stat-row-split.stat-avg .avg-value");
        if (!climbEl) return;

        const newVal = parseFloat(climbEl.textContent.replace(",", "."));
        if (!Number.isFinite(newVal)) return;

        if (lastClimbValue === 0 && newVal > 0) {
            console.log("ðŸ”„ Detected new ride, reinitializing overlays...");
            initOverlays(); // re-run your overlay init
        }

        lastClimbValue = newVal;
    }, checkInterval);
}

// Start persistent watch
watchTotalClimbPersistent();


const initTimer = setInterval(() => { if (initOverlays()) clearInterval(initTimer); }, 500);

setInterval(() => {
    if (total_km && points && climbs.length) {
        //console.log("climbs detected:", climbs.length, climbs);

        drawActiveClimbOverlay(points, climbs, total_km, getMyKm());
    }
}, ACTIVE_UPDATE_INTERVAL);

})(); // end userscript
