// ==UserScript==
// @name         Biketerra LeaderOverlay + Climbs + Flat + List (Merge + Correct Height v1)
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Leader overlay + climbs + flats + segment list - merge climbs <0.25km appart and include short flats between climbs; correct height calculation (counts all positive dy)
// @author       Josef N
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';
    console.log("[Leader Overlay] Merge+Height v1 started");

    const checkInterval = 500; // ms
    const MERGE_GAP_KM = 0.25; // merge threshold
    const DISPLAY_SLOPE_THRESHOLD = 2.5; // % - climbs under this are not shown but counted in height

    let routeLength = 0; // km (detected from page)
    let totalClimb = 0; // meter (detected from page)

    let overlay, logContainer, leaderLine, myPosLine;
    let segmentListOverlay, segmentListContainer;
    let currentMyX = 0, currentLeaderX = 0;
    let segmentRects = [];

    const gradeColors = {
        a: '#FF6262', b: '#DC5666', c: '#B14674', d: '#7F347C', e: '#572667',
        flat: '#0008'
    };
    function getGradeColor(grade) { return gradeColors[grade] || '#ffffff'; }

    // --- Read UI positions / route stats
    function getLeaderAndMyPos(log=false) {
        let leaderKm = 0;
        const ridersMain = document.querySelector('.riders-main');
        if (ridersMain) {
            const firstRider = ridersMain.querySelector('.rider');
            if (firstRider) {
                const leaderDistanceEl = firstRider.querySelector('.rider-distance .monospace');
                if (leaderDistanceEl) {
                    const numberText = leaderDistanceEl.textContent.trim();
                    let unitText = 'km';
                    let nextNode = leaderDistanceEl.nextSibling;
                    while (nextNode) {
                        if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() !== '') {
                            unitText = nextNode.textContent.trim().toLowerCase();
                            break;
                        }
                        nextNode = nextNode.nextSibling;
                    }
                    let value = parseFloat(numberText) || 0;
                    if (unitText.includes('meter')) value /= 1000;
                    leaderKm = numberText.startsWith('-') ? -value : value;
                }
            }
        }

        let myPosKm = 0;
        const statsGrid = document.querySelector('.stats-grid');
        if (statsGrid) {
            const statRows = statsGrid.querySelectorAll('.stat-row.svelte-1wfcwp8');
            if (statRows.length >= 4) {
                const avgValueEl = statRows[2].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
                if (avgValueEl) {
                    myPosKm = parseFloat(avgValueEl.textContent.trim()) || 0;
                    if (routeLength === 0 && myPosKm > 0) {
                        routeLength = myPosKm;
                        if(log) console.log("[DEBUG] Route length detected:", routeLength, "km");
                    }
                }
                const climbValueEl = statRows[3].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
                if (climbValueEl) {
                    const climbText = climbValueEl.textContent.trim();
                    let climbUnit = 'm';
                    let nextNode = climbValueEl.nextSibling;
                    while(nextNode) {
                        if(nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() !== '') {
                            climbUnit = nextNode.textContent.trim().toLowerCase();
                            break;
                        }
                        nextNode = nextNode.nextSibling;
                    }
                    let value = parseFloat(climbText) || 0;
                    if(climbUnit.includes('km')) value *= 1000;
                    totalClimb = value;
                    if(log) console.log("[DEBUG] Total climb detected:", totalClimb, "m");
                }
            }
        }

        if (log) console.log("[DEBUG] LeaderKm:", leaderKm, "MyPosKm:", myPosKm, "TotalClimb:", totalClimb);
        return { leaderKm, myPosKm };
    }

    // --- Overlay UI creation
    function createOverlay() {
        if(overlay) return overlay;

        overlay = document.createElement('div');
        Object.assign(overlay.style,{
            position:'fixed', bottom:'8px', left:'50%', transform:'translateX(-50%)',
            width:'50vw', height:'95px', background:'rgba(0,0,0,0.0)',
            zIndex:'9999', border:'1px solid rgba(255,255,255,0.05)', borderRadius:'6px',
            cursor:'default', display:'flex', flexDirection:'column', alignItems:'center', justifyContent:'center',
            overflow:'hidden', color: 'white'
        });
        document.body.appendChild(overlay);

        logContainer = document.createElement('div');
        Object.assign(logContainer.style,{
            flex:'1', width:'100%', fontSize:'12px', color:'white', overflowY:'auto', textAlign:'center'
        });
        overlay.appendChild(logContainer);

        const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
        svg.setAttribute('width','100%'); svg.setAttribute('height','100%');
        overlay.appendChild(svg);

        const height = overlay.clientHeight * 0.8;

        myPosLine = document.createElementNS("http://www.w3.org/2000/svg","line");
        myPosLine.setAttribute('y1',0); myPosLine.setAttribute('y2',height);
        myPosLine.setAttribute('stroke','lime'); myPosLine.setAttribute('stroke-width',0);
        svg.appendChild(myPosLine);

        leaderLine = document.createElementNS("http://www.w3.org/2000/svg","line");
        leaderLine.setAttribute('y1',0); leaderLine.setAttribute('y2',height);
        leaderLine.setAttribute('stroke','red'); leaderLine.setAttribute('stroke-width',2);
        svg.appendChild(leaderLine);

        return overlay;
    }

    function createSegmentListOverlay() {
        if(segmentListOverlay) return segmentListOverlay;
        segmentListOverlay = document.createElement('div');
        Object.assign(segmentListOverlay.style,{
            position:'fixed', bottom:'111px', left:'50%', transform:'translateX(-50%)',
            width:'32vw', maxHeight:'320px', overflowY:'auto',
            background:'#000a', color:'white', fontSize:'12px', border:'1px solid rgba(255,255,255,0.08)',
            borderRadius:'6px', padding:'6px', zIndex:'9999'
        });
        document.body.appendChild(segmentListOverlay);
        segmentListContainer = document.createElement('div');
        segmentListOverlay.appendChild(segmentListContainer);
        return segmentListOverlay;
    }

    function findMainPolyline() {
        const svg = document.querySelector('svg.pathSVG');
        if(!svg) return null;
        const all = Array.from(svg.querySelectorAll('polyline'));
        if(!all.length) return null;
        return all.sort((a,b)=>{
            const la = (a.getAttribute('points')||'').split(' ').length;
            const lb = (b.getAttribute('points')||'').split(' ').length;
            return lb - la;
        })[0] || null;
    }

    function parsePoints(pointsAttr) {
        if(!pointsAttr) return [];
        return pointsAttr.split(' ')
            .filter(Boolean)
            .map(pt => {
                const [x,y] = pt.split(',').map(Number);
                return {x,y};
            });
    }

    // --- Compute primitive segments (no merge) but with correct real height scaling ---
    function computePrimitives() {
        if(!routeLength || !totalClimb) return [];
        const mainPL = findMainPolyline();
        if(!mainPL) return [];
        const points = parsePoints(mainPL.getAttribute('points'));
        if(!points.length) return [];

        // compute total positive Y (in polyline coordinate units)
        let totalPosY = 0;
        for (let i = 1; i < points.length; i++) {
            const dy = points[i-1].y - points[i].y;
            if (dy > 0) totalPosY += dy;
        }
        const scale = totalPosY > 0 ? (totalClimb / totalPosY) : 0;

        const primitives = [];
        for (let i = 1; i < points.length; i++) {
            const prev = points[i-1];
            const curr = points[i];

            const dxKm = (curr.x - prev.x) * routeLength;
            const dyRaw = prev.y - curr.y;
            const dyM = dyRaw > 0 ? dyRaw * scale : 0; // only positive ascent counts for climb height
            const slopePercent = (dxKm !== 0) ? (dyM / (dxKm * 1000)) * 100 : 0;

            const isClimb = dyM > 0; // treat any positive dy as climb primitive (even if slope small)
            let grade = 'flat';
            if (slopePercent >= 40) grade = 'a';
            else if (slopePercent >= 20) grade = 'b';
            else if (slopePercent >= 10) grade = 'c';
            else if (slopePercent >= 5)  grade = 'd';
            else if (slopePercent > 0)   grade = 'e';

            primitives.push({
                start: prev.x,
                end: curr.x,
                dxKm,
                dyM,
                avgSlope: slopePercent,
                isClimb,
                grade
            });
        }

        return primitives;
    }

    // --- Build primitives grouped into blocks of same type (climb vs flat) ---
    function buildBlocks(primitives) {
        const blocks = [];
        if (!primitives.length) return blocks;
        let cur = { ...primitives[0], start:primitives[0].start, end:primitives[0].end };
        for (let i=1;i<primitives.length;i++){
            const p = primitives[i];
            const sameType = (p.isClimb && cur.isClimb) || (!p.isClimb && !cur.isClimb);
            if (sameType) {
                cur.dxKm += p.dxKm;
                cur.dyM += p.dyM;
                cur.end = p.end;
                // avgSlope will be recomputed when needed
            } else {
                // push current block
                cur.avgSlope = (cur.dxKm>0) ? (cur.dyM / (cur.dxKm * 1000)) * 100 : 0;
                blocks.push(cur);
                cur = { ...p, start:p.start, end:p.end };
            }
        }
        cur.avgSlope = (cur.dxKm>0) ? (cur.dyM / (cur.dxKm * 1000)) * 100 : 0;
        blocks.push(cur);
        return blocks;
    }

    // --- Merge logic on blocks according to your rules ---
    function mergeClimbsAndShortFlats(blocks) {
        const merged = [];
        let i = 0;
        while (i < blocks.length) {
            const block = blocks[i];
            if (!block.isClimb) {
                // skip isolated flats — they will be absorbed by neighbors if short and between climbs
                i++;
                continue;
            }

            // start new combined climb from this block
            let combined = {
                start: block.start,
                end: block.end,
                dxKm: block.dxKm,
                dyM: block.dyM,
            };

            let j = i + 1;
            while (j < blocks.length) {
                const next = blocks[j];
                if (next.isClimb) {
                    // gap between combined.end and next.start (should be zero if blocks adjacent)
                    const gapKm = next.start * routeLength - combined.end * routeLength;
                    if (gapKm <= MERGE_GAP_KM) {
                        // merge next climb
                        combined.dxKm += next.dxKm;
                        combined.dyM += next.dyM;
                        combined.end = next.end;
                        j++;
                        continue;
                    } else {
                        break;
                    }
                } else {
                    // next is flat block(s). sum consecutive flats
                    let flatTotal = next.dxKm;
                    let k = j;
                    while (k+1 < blocks.length && !blocks[k+1].isClimb) {
                        k++;
                        flatTotal += blocks[k].dxKm;
                    }
                    const afterIdx = k + 1;
                    if (afterIdx < blocks.length && blocks[afterIdx].isClimb) {
                        // there is a climb after these flats
                        if (flatTotal <= MERGE_GAP_KM) {
                            // include flat(s) and the following climb into combined
                            const nextClimb = blocks[afterIdx];
                            combined.dxKm += flatTotal + nextClimb.dxKm;
                            combined.dyM += nextClimb.dyM; // flats add 0 dy
                            combined.end = nextClimb.end;
                            // advance j to after the included nextClimb
                            j = afterIdx + 1;
                            continue;
                        } else {
                            // flats too long: do not absorb next climb
                            break;
                        }
                    } else {
                        // no climb after flats (end of route) -> do not include
                        break;
                    }
                }
            }

            // compute avgSlope for combined
            combined.avgSlope = (combined.dxKm > 0) ? (combined.dyM / (combined.dxKm * 1000)) * 100 : 0;

            merged.push(combined);
            i = j;
        }

        return merged;
    }

    // --- Draw / List logic ---
  let segmentListBuilt = false; // ny flagga högst upp i scriptet
let climbProgressOverlay; // overlay-element
// --- GLOBAL VAR --- högst upp i scriptet
// --- GLOBAL VAR --- högst upp i scriptet
// --- GLOBAL VAR --- högst upp i scriptet
window.climbProgressOverlay = window.climbProgressOverlay || null;

window.climbProgressBar = window.climbProgressBar || null;

// --- Skapar overlay-rutan med progressbar (enda gången) ---
function createClimbProgressOverlay() {
    if (window.climbProgressOverlay) return window.climbProgressOverlay;

    const overlay = document.createElement('div');
    Object.assign(overlay.style, {
        position: 'fixed',
        left: '50%',
        transform: 'translateX(-50%)',
        background: '#000c',
        color: 'white',
        padding: '8px 12px',
        borderRadius: '6px',
        fontSize: '13px',
        fontWeight: 'bold',
        zIndex: '9999',
        minWidth: '260px',
        width:'32vw',
        textAlign: 'center',
        transition: 'background 0.2s'
    });

    const textDiv = document.createElement('div');
    textDiv.style.marginBottom = '4px';
    overlay.appendChild(textDiv);

    const barContainer = document.createElement('div');
    Object.assign(barContainer.style, {
        width: '100%',
        height: '12px',
        background: '#2228',
        borderRadius: '6px',
        overflow: 'hidden'
    });

    const bar = document.createElement('div');
    Object.assign(bar.style, {
        width: '0%',
        height: '100%',
        background: 'lime',
        borderRadius: '6px',
        transition: 'width 0.2s'
    });

    barContainer.appendChild(bar);
    overlay.appendChild(barContainer);

    document.body.appendChild(overlay);

    window.climbProgressOverlay = overlay;
    window.climbProgressBar = { bar, textDiv };

    // --- placera precis ovanför segmentListOverlay ---
    function updatePosition() {
        if(segmentListOverlay){
            const rect = segmentListOverlay.getBoundingClientRect();
            overlay.style.bottom = `${window.innerHeight - rect.top + 8}px`; // 8px mellanrum
        }
    }
    updatePosition();
    window.addEventListener('resize', updatePosition);

    return overlay;
}

// --- Uppdaterar climb progress med progressbar ---
function updateClimbProgress(mergedClimbs, myPosKm) {
    const overlayEl = createClimbProgressOverlay();
    const { bar, textDiv } = window.climbProgressBar;

    if (!mergedClimbs || !mergedClimbs.length) {
        textDiv.textContent = 'No climbs';
        bar.style.width = '0%';
        overlayEl.style.background = '#000c';
        return;
    }

    const climbsToShow = mergedClimbs.filter(c => c.avgSlope >= DISPLAY_SLOPE_THRESHOLD);
    if (!climbsToShow.length) {
        textDiv.textContent = 'No climbs above threshold';
        bar.style.width = '0%';
        overlayEl.style.background = '#000c';
        return;
    }

    // Hämta aktuell speed
    let speedKPH = 0;
    const statsGrid = document.querySelector('.stats-grid');
    if (statsGrid) {
        const statRows = statsGrid.querySelectorAll('.stat-row.svelte-1wfcwp8');
        if (statRows.length >= 1) {
            const speedEl = statRows[0].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
            if (speedEl) {
                let value = parseFloat(speedEl.textContent.trim()) || 0;
                speedKPH = value;
            }
        }
    }

    let nextClimb = null;
    let nextIndex = -1;

    for (let i = 0; i < climbsToShow.length; i++) {
        const climb = climbsToShow[i];
        const climbStartInv = routeLength - climb.start * routeLength;
        const climbEndInv   = routeLength - climb.end * routeLength;

        if (myPosKm > climbStartInv) {
            nextClimb = climb;
            nextIndex = i;
            break;
        } else if (myPosKm <= climbStartInv && myPosKm >= climbEndInv) {
            nextClimb = climb;
            nextIndex = i;
            break;
        }
    }

    if (!nextClimb) {
        // visa sista climb-tiden i 10 sekunder om den precis slutat
        if (window.climbFinishedTime && Date.now() - window.climbFinishedTime < 10000) {
            textDiv.textContent = window.lastClimbText || 'Finished all climbs';
            bar.style.width = '100%';
        } else {
            textDiv.textContent = 'Finished all climbs';
            bar.style.width = '100%';
            window.currentClimbStartTime = null;
            window.currentClimbIndex = -1;
            window.climbFinishedTime = null;
        }
        overlayEl.style.background = '#000c';
        return;
    }

    const climbStartInv = routeLength - nextClimb.start * routeLength;
    const climbEndInv   = routeLength - nextClimb.end * routeLength;

    let displayText = '';
    let bgColor = '#000c';
    let progressPercent = 0;

    const now = Date.now();

    if (myPosKm > climbStartInv) {
        // före climb
        displayText = `Next climb #${nextIndex + 1} in: ${(myPosKm - climbStartInv).toFixed(2)} km`;
        progressPercent = 0;
        bgColor = '#0008';
        window.currentClimbStartTime = null;
        window.currentClimbIndex = -1;
    } else if (myPosKm <= climbStartInv && myPosKm >= climbEndInv) {
        // på climb
        const climbRemainingKm = myPosKm - climbEndInv;
        const climbTotalKm     = climbStartInv - climbEndInv;
        const climbRemainingM  = nextClimb.dyM * (climbRemainingKm / climbTotalKm);

        // average grade kvar
        const avgSlopeRemaining = climbRemainingM / (climbRemainingKm * 1000) * 100;

        // tid kvar
        let timeRemainingText = '--';
        if (speedKPH > 0) {
            const hours = climbRemainingKm / speedKPH;
            const minutes = Math.floor(hours * 60);
            const seconds = Math.round((hours * 3600) % 60);
            timeRemainingText = `${minutes}m ${seconds}s`;
        }

        // --- Climb duration ---
        if (window.currentClimbIndex !== nextIndex) {
            // ny climb start
            window.currentClimbStartTime = now;
            window.currentClimbIndex = nextIndex;
            window.climbFinishedTime = null;
        }

        let elapsedText = '';
        if (window.currentClimbStartTime) {
            const elapsedSec = Math.floor((now - window.currentClimbStartTime) / 1000);
            const elapsedMin = Math.floor(elapsedSec / 60);
            const elapsedRem = elapsedSec % 60;
            elapsedText = ` | Duration: ${elapsedMin}m ${elapsedRem}s`;
        }

        displayText = `Climb #${nextIndex + 1} remaining: ${climbRemainingKm.toFixed(2)} km | ${climbRemainingM.toFixed(2)} m | Avg: ${avgSlopeRemaining.toFixed(2)}% | ETA: ${timeRemainingText}${elapsedText}`;

        progressPercent = ((climbTotalKm - climbRemainingKm) / climbTotalKm) * 100;

        let grade = 'e';
        if (nextClimb.avgSlope >= 40) grade='a';
        else if (nextClimb.avgSlope >= 20) grade='b';
        else if (nextClimb.avgSlope >= 10) grade='c';
        else if (nextClimb.avgSlope >= 5)  grade='d';
        else grade='e';
        bgColor = getGradeColor(grade) + '88';
    }

    // om climb är klar, spara text för 10 sekunder
    if (myPosKm < climbEndInv && window.currentClimbIndex === nextIndex) {
        window.climbFinishedTime = now;
        window.lastClimbText = displayText;
        window.currentClimbStartTime = null;
        window.currentClimbIndex = -1;
    }

    textDiv.textContent = displayText;
    bar.style.width = progressPercent.toFixed(2) + '%';
    overlayEl.style.background = bgColor;
}

function drawSegments(mergedClimbs, primitives) {
    const overlayEl = overlay;
    if(!overlayEl) return;
    const overlaySvg = overlay.querySelector('svg');
    const width = overlayEl.clientWidth;
    const height = overlaySvg.clientHeight;

    // clear old rects (för overlay) - alltid rita linjer för position
    segmentRects.forEach(r=>r.remove());
    segmentRects = [];

    createSegmentListOverlay();

    // --- NYTT: bygg segment listan bara EN gång ---
    if(!segmentListBuilt) {
        segmentListContainer.innerHTML = '';

        // Vi bygger listan på samma sätt som tidigare
        let totalHeightFromPrimitives = 0;
        primitives.forEach(p => { totalHeightFromPrimitives += (p.dyM || 0); });

        let displayIndex = 1;
        for (let m of mergedClimbs) {
            if (m.avgSlope < DISPLAY_SLOPE_THRESHOLD) continue;

            const startKm = (m.start * routeLength) || 0;
            const endKm = (m.end * routeLength) || 0;
            const lenKm = Math.max(0, endKm - startKm);

const div = document.createElement('div');
div.style.display = 'flex';
div.style.justifyContent = 'space-between';
div.style.padding = '4px 0';
div.style.borderBottom = '1px dashed rgba(255,255,255,0.04)';
//div.style.fontFamily = 'monospace';
div.style.whiteSpace = 'nowrap'; // <--- ingen radbrytning
div.style.overflow = 'hidden';
div.style.textOverflow = 'ellipsis';

const colStyle = 'flex:1; text-align:right; overflow:hidden; text-overflow:ellipsis;';

div.innerHTML = `
    <div style="flex:1; text-align:left;">#${displayIndex} CLIMB</div>
    <div style="${colStyle}">${startKm.toFixed(2)}→${endKm.toFixed(2)} km</div>
    <div style="${colStyle}">${lenKm.toFixed(2)} km</div>
    <div style="${colStyle}">${m.dyM.toFixed(0)} m</div>
    <div style="${colStyle}">${m.avgSlope.toFixed(2)}%</div>
`;
segmentListContainer.appendChild(div);

            displayIndex++;
        }



        segmentListBuilt = true; // flagga att listan nu är byggd
    }

    // --- Overlay rektanglar (klättringar) ritas alltid dynamiskt ---
    for (let m of mergedClimbs) {
        if (m.avgSlope < DISPLAY_SLOPE_THRESHOLD) continue;

        const x = m.start * width;
        const w = Math.max(1, (m.end - m.start) * width);

        const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute('x', x);
        rect.setAttribute('y', 0);
        rect.setAttribute('width', w);
        rect.setAttribute('height', height);

        let grade = 'e';
        if (m.avgSlope >= 40) grade='a';
        else if (m.avgSlope >= 20) grade='b';
        else if (m.avgSlope >= 10) grade='c';
        else if (m.avgSlope >= 5) grade='d';
        else grade='e';

        rect.setAttribute('fill', getGradeColor(grade));
        rect.setAttribute('opacity', 0.36);
        overlaySvg.appendChild(rect);
        segmentRects.push(rect);
    }
}

    // --- Main update ---
    function updateOverlay() {
        const overlayEl = createOverlay();
        const pos = getLeaderAndMyPos(false);

       // logContainer.textContent = `MyPos ${pos.myPosKm.toFixed(1)} km`;

        const svg = overlayEl.querySelector('svg');
        const width = overlayEl.clientWidth;
        const height = svg.clientHeight;

        if(!routeLength) return;

        const targetMyX = ((routeLength - pos.myPosKm) / routeLength) * width;
        const leaderAbs = pos.myPosKm - pos.leaderKm;
        const targetLeaderX = ((routeLength - leaderAbs) / routeLength) * width;

        currentMyX += (targetMyX - currentMyX) * 0.2;
        currentLeaderX += (targetLeaderX - currentLeaderX) * 0.2;

        myPosLine.setAttribute('x1',currentMyX);
        myPosLine.setAttribute('x2',currentMyX);
        myPosLine.setAttribute('y2',height);

        leaderLine.setAttribute('x1',currentLeaderX);
        leaderLine.setAttribute('x2',currentLeaderX);
        leaderLine.setAttribute('y2',height);

        // compute primitives (no merge) with correct scaling
        const primitives = computePrimitives();

        // build blocks of same type (climb vs flat)
        const blocks = buildBlocks(primitives);

        // merge climbs and short flats between them
        const mergedClimbs = mergeClimbsAndShortFlats(blocks);

        // draw only merged climbs that meet display threshold, and the total from primitives
        drawSegments(mergedClimbs, primitives);
        updateClimbProgress(mergedClimbs, pos.myPosKm);

    }

    setInterval(updateOverlay, checkInterval);
    setTimeout(()=>getLeaderAndMyPos(true), 1500);

})();
