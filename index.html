<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>GPX Snap/Align Tool â€” Smooth Turns SMOOTH?</title>
<style>
  body { font-family: sans-serif; margin:0; padding:0; }
  #map { width: 100%; height: 80vh; border-bottom: 2px solid #ccc; }
  #controls { padding: 10px; }
  button, input { padding: 8px 14px; margin-right:10px; }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="controls">
  <input type="file" id="gpxFile" accept=".gpx"> 
  <button id="snapBtn">Snap Selected Area</button>
  <button id="snapPathBtn">Snap to Path</button>
  <button id="downloadBtn">Download Updated GPX</button>
</div>

<script>
let map = L.map('map').setView([0,0], 2);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let editableLayers = new L.FeatureGroup().addTo(map);
let drawControl = new L.Control.Draw({
    draw: { polygon:true, rectangle:true, polyline:false, circle:false, circlemarker:false, marker:false },
    edit: { featureGroup: editableLayers }
});
map.addControl(drawControl);

let gpxPoints = [], gpxLayer = null, selectionShape = null;
let refLayer = L.layerGroup().addTo(map);
let tgtLayer = L.layerGroup().addTo(map);
let referencePath = []; 

// --- Utilities ---
function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
function pointInSelection(p){
    if(!selectionShape) return false;
    if(selectionShape instanceof L.Rectangle){
        const b = selectionShape.getBounds();
        return p.lat>=b.getSouth() && p.lat<=b.getNorth() && p.lon>=b.getWest() && p.lon<=b.getEast();
    } else if(selectionShape instanceof L.Polygon){
        const poly = selectionShape.getLatLngs()[0];
        const x = p.lat, y = p.lon;
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++){
            const xi = poly[i].lat, yi = poly[i].lng;
            const xj = poly[j].lat, yj = poly[j].lng;
            const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
            if(intersect) inside=!inside;
        }
        return inside;
    }
    return false;
}
function projectPointOnSegment(p,a,b){
    const ax=a.lon, ay=a.lat, bx=b.lon, by=b.lat, px=p.lon, py=p.lat;
    const abx=bx-ax, aby=by-ay;
    const t=Math.max(0,Math.min(1,((px-ax)*abx+(py-ay)*aby)/(abx*abx+aby*aby)));
    return { lon: ax + t*abx, lat: ay + t*aby, ele: a.ele + t*(b.ele - a.ele) };
}

// --- Catmull-Rom Spline Smoothing ---
function catmullRomSpline(points, samplesPerSegment=5){
    if(points.length < 3) return points.slice();
    const result = [];
    function interpolate(p0,p1,p2,p3,t){
        const t2=t*t, t3=t2*t;
        return {
            lat: 0.5*((2*p1.lat)+(-p0.lat+p2.lat)*t + (2*p0.lat-5*p1.lat+4*p2.lat-p3.lat)*t2 + (-p0.lat+3*p1.lat-3*p2.lat+p3.lat)*t3),
            lon: 0.5*((2*p1.lon)+(-p0.lon+p2.lon)*t + (2*p0.lon-5*p1.lon+4*p2.lon-p3.lon)*t2 + (-p0.lon+3*p1.lon-3*p2.lon+p3.lon)*t3),
            ele: 0.5*((2*p1.ele)+(-p0.ele+p2.ele)*t + (2*p0.ele-5*p1.ele+4*p2.ele-p3.ele)*t2 + (-p0.ele+3*p1.ele-3*p2.ele+p3.ele)*t3)
        };
    }
    result.push(points[0]);
    for(let i=0;i<points.length-1;i++){
        const p0 = points[Math.max(i-1,0)];
        const p1 = points[i];
        const p2 = points[i+1];
        const p3 = points[Math.min(i+2,points.length-1)];
        for(let j=1;j<=samplesPerSegment;j++){
            const t=j/samplesPerSegment;
            result.push(interpolate(p0,p1,p2,p3,t));
        }
    }
    return result;
}

// --- GPX Loading ---
document.getElementById('gpxFile').addEventListener('change', async e=>{
    let file=e.target.files[0];
    if(!file) return;
    let text=await file.text();
    let xml=new DOMParser().parseFromString(text,"application/xml");
    let geo=toGeoJSON.gpx(xml);
    gpxPoints=geo.features[0].geometry.coordinates.map(c=>({lon:c[0],lat:c[1],ele:c[2]||0}));
    referencePath = gpxPoints.map(p=>({...p}));
    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer=L.polyline(gpxPoints.map(p=>[p.lat,p.lon]),{color:'red'}).addTo(map);
    map.fitBounds(gpxLayer.getBounds());
});

// --- Drawing ---
map.on(L.Draw.Event.CREATED, function(e){
    if(selectionShape) editableLayers.removeLayer(selectionShape);
    selectionShape=e.layer;
    editableLayers.addLayer(selectionShape);
});

// --- Snap Selected Area ---
function snapArea(){
    if(!selectionShape || gpxPoints.length===0) return;
    let indices=gpxPoints.map((p,i)=>pointInSelection(p)?i:-1).filter(i=>i>=0);
    if(indices.length<2){ alert("Select at least 2 points."); return; }
    const cumDist=[0];
    for(let i=1;i<gpxPoints.length;i++){
        const dx=gpxPoints[i].lon-gpxPoints[i-1].lon;
        const dy=gpxPoints[i].lat-gpxPoints[i-1].lat;
        cumDist.push(cumDist[i-1]+Math.sqrt(dx*dx+dy*dy));
    }
    indices.sort((a,b)=>cumDist[a]-cumDist[b]);
    const mid=Math.floor(indices.length/2);
    const refIdx=indices.slice(0,mid), tgtIdx=indices.slice(mid);
    refLayer.clearLayers(); tgtLayer.clearLayers();
    refIdx.forEach(i=>L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon],{radius:4,color:'blue',fillColor:'blue',fillOpacity:0.9}).addTo(refLayer));
    tgtIdx.forEach(i=>L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon],{radius:4,color:'orange',fillColor:'orange',fillOpacity:0.9}).addTo(tgtLayer));
    const refPoints=refIdx.map(i=>gpxPoints[i]);
    const tgtPoints=tgtIdx.map(i=>gpxPoints[i]);
    const refDist=[0]; for(let i=1;i<refPoints.length;i++){const dx=refPoints[i].lon-refPoints[i-1].lon; const dy=refPoints[i].lat-refPoints[i-1].lat; refDist.push(refDist[i-1]+Math.sqrt(dx*dx+dy*dy)); }
    const snappedTargetData=[];
    for(let k=0;k<tgtPoints.length;k++){
        const p=tgtPoints[k];
        let best=null, bestDist=Infinity, snapDist=0;
        for(let j=0;j<refPoints.length-1;j++){
            const a=refPoints[j], b=refPoints[j+1];
            const s=projectPointOnSegment(p,a,b);
            const d=(s.lon-p.lon)**2+(s.lat-p.lat)**2;
            if(d<bestDist){ bestDist=d; best=s; snapDist=refDist[j]+Math.sqrt((s.lon-a.lon)**2+(s.lat-a.lat)**2); }
        }
        if(best) snappedTargetData.push({originalIndex:tgtIdx[k],snappedPoint:best,distOnRef:snapDist});
    }
    snappedTargetData.sort((a,b)=>a.distOnRef-b.distOnRef);
    snappedTargetData.forEach(d=>{gpxPoints[d.originalIndex]=d.snappedPoint;});
    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer=L.polyline(gpxPoints.map(p=>[p.lat,p.lon]),{color:'blue'}).addTo(map);
}

// --- Snap to External Path (OSRM) ---
async function snapToExternalPath(){
    if(!selectionShape || gpxPoints.length===0) return;
    const indices=gpxPoints.map((p,i)=>pointInSelection(p)?i:-1).filter(i=>i>=0);
    if(indices.length===0){ alert("Select at least one point."); return; }
    indices.sort((a,b)=>a-b);
    const start=indices[0], end=indices[indices.length-1];
    const segment=gpxPoints.slice(start,end+1);
    const origDist=[0]; for(let i=1;i<segment.length;i++){ const dx=segment[i].lon-segment[i-1].lon; const dy=segment[i].lat-segment[i-1].lat; origDist.push(origDist[i-1]+Math.sqrt(dx*dx+dy*dy)); }
    const totalOrigDist=origDist[origDist.length-1];
    function interpolateElevation(f){ if(f<=0)return segment[0].ele; if(f>=1)return segment[segment.length-1].ele; const target=f*totalOrigDist; for(let i=0;i<origDist.length-1;i++){ if(origDist[i]<=target && origDist[i+1]>=target){ const span=origDist[i+1]-origDist[i]; const localF=(target-origDist[i])/span; return segment[i].ele + localF*(segment[i+1].ele-segment[i].ele); } } return segment[segment.length-1].ele; }
    const coordsString=indices.map(i=>`${gpxPoints[i].lon},${gpxPoints[i].lat}`).join(';');
    const OSRM_URL=`https://router.project-osrm.org/match/v1/driving/${coordsString}?overview=full&geometries=geojson&tidy=true`;
    document.getElementById('snapPathBtn').disabled=true;
    try{
        const resp=await fetch(OSRM_URL);
        const data=await resp.json();
        if(data.code!=="Ok"||!data.matchings||data.matchings.length===0){ alert("Map matching failed."); console.log(data); return; }
        let denseGeom=data.matchings[0].geometry.coordinates;
        const osrmDist=[0]; for(let i=1;i<denseGeom.length;i++){ const dx=denseGeom[i][0]-denseGeom[i-1][0]; const dy=denseGeom[i][1]-denseGeom[i-1][1]; osrmDist.push(osrmDist[i-1]+Math.sqrt(dx*dx+dy*dy)); }
        const totalOsrmDist=osrmDist[osrmDist.length-1];
        let newPoints=denseGeom.map((c,i)=>({lon:c[0],lat:c[1],ele:interpolateElevation(osrmDist[i]/totalOsrmDist)}));
        newPoints=catmullRomSpline(newPoints,5); // ðŸ”¥ Smooth all sharp turns
        gpxPoints=[...gpxPoints.slice(0,start), ...newPoints, ...gpxPoints.slice(end+1)];
        tgtLayer.clearLayers();
        if(gpxLayer) map.removeLayer(gpxLayer);
        gpxLayer=L.polyline(gpxPoints.map(p=>[p.lat,p.lon]),{color:'green'}).addTo(map);
        console.log("OSRM geometry inserted with smooth turns:",newPoints.length,"points");
    }catch(err){ console.error(err); alert("Network or OSRM error."); }
    finally{ document.getElementById('snapPathBtn').disabled=false; }
}

// --- Download ---
function generateGPX(){
    let gpx=`<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="GPX Snap Tool">\n<trk><trkseg>`;
    gpxPoints.forEach(p=>gpx+=`\n<trkpt lat="${p.lat}" lon="${p.lon}"><ele>${p.ele}</ele></trkpt>`);
    gpx+=`\n</trkseg></trk></gpx>`; return gpx;
}
document.getElementById('downloadBtn').onclick=()=>{const blob=new Blob([generateGPX()],{type:'application/gpx+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='snapped.gpx'; a.click();};

document.getElementById('snapBtn').onclick=snapArea;
document.getElementById('snapPathBtn').onclick=snapToExternalPath;
</script>
</body>
</html>
