<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>GPX Snap/Align Tool</title>
<style>
  body { font-family: sans-serif; margin:0; padding:0; }
  #map { width: 100%; height: 80vh; border-bottom: 2px solid #ccc; }
  #controls { padding: 10px; }
  button, input { padding: 8px 14px; margin-right:10px; }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="controls">
  <input type="file" id="gpxFile" accept=".gpx"> 
  <button id="snapBtn">Snap Selected Area</button>
  <button id="snapPathBtn">Snap to Path</button>
  <button id="smoothBtn">Smooth Selected Turns</button>
  <button id="downloadBtn">Download Updated GPX</button>
</div>

<script>
let map = L.map('map').setView([0,0], 2);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let editableLayers = new L.FeatureGroup().addTo(map);
let drawControl = new L.Control.Draw({
    draw: { polygon:true, rectangle:true, polyline:false, circle:false, circlemarker:false, marker:false },
    edit: { featureGroup: editableLayers }
});
map.addControl(drawControl);

let gpxPoints = [], gpxLayer = null, selectionShape = null;
let refLayer = L.layerGroup().addTo(map);
let tgtLayer = L.layerGroup().addTo(map);
let pointLayer = L.layerGroup().addTo(map);
let referencePath = []; // for snapToPath

// Helper function to introduce a delay for OSRM rate limiting
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Insert extra points at sharp angles to make curves smoother
function smoothSharpTurns(points, angleThresholdDeg = 20, extraPoints = 3) {

    function angle(a, b, c) {
        const abx = b.lon - a.lon, aby = b.lat - a.lat;
        const cbx = b.lon - c.lon, cby = b.lat - c.lat;

        const dot = abx * cbx + aby * cby;
        const mag1 = Math.sqrt(abx*abx + aby*aby);
        const mag2 = Math.sqrt(cbx*cbx + cby*cby);

        if (mag1 === 0 || mag2 === 0) return 180;

        // clamp for numerical safety
        const cosv = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
        return Math.acos(cosv) * (180 / Math.PI);
    }

    if (!points || points.length < 3) return points.slice();

    const result = [points[0]];

    for (let i = 1; i < points.length - 1; i++) {
        const a = points[i - 1];
        const b = points[i];
        const c = points[i + 1];

        const ang = angle(a, b, c);

        if (ang < angleThresholdDeg) {
            // Insert points between b and c
            for (let j = 1; j <= extraPoints; j++) {
                const t = j / (extraPoints + 1);
                result.push({
                    lat: b.lat * (1 - t) + c.lat * t,
                    lon: b.lon * (1 - t) + c.lon * t,
                    ele:  b.ele * (1 - t) + c.ele * t
                });
            }
        }

        result.push(b);
    }

    result.push(points[points.length - 1]);
    return result;
}

// Densify path
function densifyPath(points, step=0.00001){
    if (!points || points.length < 2) return points.slice();
    const densified=[];
    for(let i=0;i<points.length-1;i++){
        const a=points[i], b=points[i+1];
        const dx=b.lon-a.lon, dy=b.lat-a.lat, dz=(b.ele||0)-(a.ele||0);
        const dist=Math.sqrt(dx*dx+dy*dy);
        const n = Math.max(1, Math.ceil(dist/step));
        for(let j=0;j<n;j++){
            const t = j / n;
            densified.push({
                lat: a.lat + (b.lat - a.lat) * t,
                lon: a.lon + (b.lon - a.lon) * t,
                ele: (a.ele || 0) + dz * t
            });
        }
    }
    densified.push(points[points.length-1]);
    return densified;
}

// Interpolate along path by fraction (0..1)
function interpolateAlongPath(path, fraction){
    if (!path || path.length === 0) return null;
    const cumDist = [0];
    for(let i=1;i<path.length;i++){
        const dx = path[i].lon - path[i-1].lon;
        const dy = path[i].lat - path[i-1].lat;
        cumDist.push(cumDist[i-1] + Math.sqrt(dx*dx + dy*dy));
    }
    const totalDist = cumDist[cumDist.length-1];
    if (totalDist === 0) return {...path[0]};

    const targetDist = fraction * totalDist;

    for(let i=1;i<path.length;i++){
        if (cumDist[i-1] <= targetDist && targetDist <= cumDist[i]) {
            const segDist = cumDist[i] - cumDist[i-1];
            const t = segDist === 0 ? 0 : (targetDist - cumDist[i-1]) / segDist;
            return {
                lat: path[i-1].lat + t*(path[i].lat-path[i-1].lat),
                lon: path[i-1].lon + t*(path[i].lon-path[i-1].lon),
                ele: (path[i-1].ele||0) + t*((path[i].ele||0)-(path[i-1].ele||0))
            };
        }
    }
    return {...path[path.length-1]};
}

// Draw point markers for visibility
function drawPointMarkers() {
    pointLayer.clearLayers();
    if (!gpxPoints) return;
    gpxPoints.forEach(p => {
        L.circleMarker([p.lat, p.lon], {
            radius: 3,
            color: "blue",
            weight: 1,
            fillColor: "white",
            fillOpacity: 1
        }).addTo(pointLayer);
    });
}

// Load GPX
document.getElementById('gpxFile').addEventListener('change', async e => {
    let file = e.target.files[0];
    if (!file) return;
    let text = await file.text();
    loadGPX(text);
});

function loadGPX(gpxText){
    let parser = new DOMParser();
    let xml = parser.parseFromString(gpxText, "application/xml");
    let geo = toGeoJSON.gpx(xml);
    gpxPoints = geo.features[0].geometry.coordinates.map(c => ({ lon:c[0], lat:c[1], ele:c[2]||0 }));
    referencePath = gpxPoints.map(p => ({...p})); // Deep copy of points

    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p=>[p.lat,p.lon]), {color:'red'}).addTo(map);
    drawPointMarkers();
    map.fitBounds(gpxLayer.getBounds());
}

// Draw selection
map.on(L.Draw.Event.CREATED, function(event) {
    if (selectionShape) editableLayers.removeLayer(selectionShape);
    selectionShape = event.layer;
    editableLayers.addLayer(selectionShape);
});

// Check if point is inside selection
function pointInSelection(p){
    if(!selectionShape) return false;
    if(selectionShape instanceof L.Rectangle){
        const b = selectionShape.getBounds();
        return p.lat>=b.getSouth() && p.lat<=b.getNorth() && p.lon>=b.getWest() && p.lon<=b.getEast();
    } else if(selectionShape instanceof L.Polygon){
        const poly = selectionShape.getLatLngs()[0];
        const x = p.lat, y = p.lon;
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].lat, yi = poly[i].lng;
            const xj = poly[j].lat, yj = poly[j].lng;
            const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if(intersect) inside=!inside;
        }
        return inside;
    }
    return false;
}

// Project point onto segment
function projectPointOnSegment(p,a,b){
    const ax=a.lon, ay=a.lat, bx=b.lon, by=b.lat, px=p.lon, py=p.lat;
    const abx=bx-ax, aby=by-ay;
    const denom = (abx*abx+aby*aby);
    const t = denom === 0 ? 0 : Math.max(0,Math.min(1,((px-ax)*abx+(py-ay)*aby)/denom));
    return { lon: ax + t*abx, lat: ay + t*aby, ele: (a.ele||0) + t*((b.ele||0)-(a.ele||0)), t: t };
}

// --- PROGRESSIVE FORWARD-ONLY SNAP (fixes 90Â° kinks) ---
function snapArea() {
    if (!selectionShape || gpxPoints.length === 0) return;

    // Get indices of points inside selection (in track order)
    let insideIndices = gpxPoints.map((p,i) => pointInSelection(p) ? i : -1).filter(i => i >= 0);
    if (insideIndices.length < 2) { alert("Select at least 2 points."); return; }

    // Sort by their position along the full GPX (maintain track order)
    insideIndices.sort((a,b) => a - b);

    // Split into reference (first half) and target (second half)
    const mid = Math.floor(insideIndices.length / 2);
    const refIdx = insideIndices.slice(0, mid);
    const tgtIdx = insideIndices.slice(mid);

    if (refIdx.length < 2) { alert("Need at least 2 reference points."); return; }

    refLayer.clearLayers();
    tgtLayer.clearLayers();

    refIdx.forEach(i => L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon], {radius:4,color:'blue',fillColor:'blue',fillOpacity:0.9}).addTo(refLayer));
    tgtIdx.forEach(i => L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon], {radius:4,color:'orange',fillColor:'orange',fillOpacity:0.9}).addTo(tgtLayer));

    const refPoints = refIdx.map(i => gpxPoints[i]);
    const tgtPoints = tgtIdx.map(i => gpxPoints[i]);

    // Densify reference path for fine-grained snapping
    const densifiedRef = densifyPath(refPoints, 0.00001);

    // Precompute cumulative distance along densified reference
    const refDist = [0];
    for (let i = 1; i < densifiedRef.length; i++) {
        const dx = densifiedRef[i].lon - densifiedRef[i-1].lon;
        const dy = densifiedRef[i].lat - densifiedRef[i-1].lat;
        refDist.push(refDist[i-1] + Math.sqrt(dx*dx + dy*dy));
    }
    const totalRefDist = refDist[refDist.length - 1];

    // Progressive forward-only snapping
    let lastSegIndex = 0; // never go backwards
    for (let k = 0; k < tgtPoints.length; k++) {
        const p = tgtPoints[k];
        let best = null;
        let bestDistSq = Infinity;
        let bestSeg = lastSegIndex;
        let bestDistToA = 0;

        // Search only forward from lastSegIndex to end
        for (let j = lastSegIndex; j < densifiedRef.length - 1; j++) {
            const a = densifiedRef[j];
            const b = densifiedRef[j+1];
            const proj = projectPointOnSegment(p, a, b); // returns {lon,lat,ele,t}
            const dx = proj.lon - p.lon;
            const dy = proj.lat - p.lat;
            const distSq = dx*dx + dy*dy;
            if (distSq < bestDistSq) {
                bestDistSq = distSq;
                best = proj;
                bestSeg = j;
                // dist from a to projected point along segment
                const distToA = Math.sqrt((proj.lon - a.lon)**2 + (proj.lat - a.lat)**2);
                bestDistToA = distToA;
            }
        }

        if (best) {
            // compute fraction along densifiedRef
            const distOnRef = refDist[bestSeg] + bestDistToA;
            const fraction = totalRefDist === 0 ? 0 : (distOnRef / totalRefDist);
            const idxInGPX = tgtIdx[k];
            // Interpolate exact position on densifiedRef by fraction (keeps perfect alignment)
            const interp = interpolateAlongPath(densifiedRef, fraction);
            if (interp) {
                gpxPoints[idxInGPX] = interp;
            }
            // advance lastSegIndex so next point can't snap backward
            lastSegIndex = bestSeg;
        }
    }

    // Redraw polyline + points
    if (gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p => [p.lat, p.lon]), {color:'blue'}).addTo(map);
    drawPointMarkers();
}

// ðŸŸ¢ UPDATED FUNCTION: Snap to External Path using OSRM Match Service
// Replaces selected range with dense OSRM geometry and preserves elevation by interpolation
async function snapToExternalPath() {
    if (!selectionShape || gpxPoints.length === 0) return;

    const indices = gpxPoints
        .map((p, i) => pointInSelection(p) ? i : -1)
        .filter(i => i >= 0);

    if (indices.length === 0) {
        alert("Select at least one point to snap.");
        return;
    }

    indices.sort((a, b) => a - b);
    const startIndex = indices[0];
    const endIndex   = indices[indices.length - 1];

    // Extract the elevation source segment
    const originalSegment = gpxPoints.slice(startIndex, endIndex + 1);

    // Precompute cumulative distance in the original segment (for elevation interpolation)
    const origDist = [0];
    for (let i = 1; i < originalSegment.length; i++) {
        const dx = originalSegment[i].lon - originalSegment[i-1].lon;
        const dy = originalSegment[i].lat - originalSegment[i-1].lat;
        origDist.push(origDist[i - 1] + Math.sqrt(dx*dx + dy*dy));
    }
    const totalOrigDist = origDist[origDist.length - 1] || 0.000001;

    // Function to interpolate elevation based on distance fraction
    function interpolateElevation(fraction) {
        if (fraction <= 0) return originalSegment[0].ele;
        if (fraction >= 1) return originalSegment[originalSegment.length - 1].ele;

        const targetDist = fraction * totalOrigDist;

        for (let i = 0; i < origDist.length - 1; i++) {
            if (origDist[i] <= targetDist && origDist[i+1] >= targetDist) {
                const span = origDist[i+1] - origDist[i] || 1;
                const localF = (targetDist - origDist[i]) / span;
                return originalSegment[i].ele + localF * (originalSegment[i+1].ele - originalSegment[i].ele);
            }
        }
        return originalSegment[originalSegment.length - 1].ele;
    }

    // Build OSRM coordinate string
    const coordinatesString = indices
        .map(i => `${gpxPoints[i].lon},${gpxPoints[i].lat}`)
        .join(';');

    const OSRM_URL =
        `https://router.project-osrm.org/match/v1/driving/` +
        `${coordinatesString}?overview=full&geometries=geojson&tidy=true`;

    document.getElementById('snapPathBtn').disabled = true;

    try {
        const response = await fetch(OSRM_URL);
        const data = await response.json();

        if (data.code !== "Ok" || !data.matchings || data.matchings.length === 0) {
            alert("Map matching failed.");
            console.log(data);
            return;
        }

        // Full OSRM geometry (lon, lat)
        const denseGeom = data.matchings[0].geometry.coordinates;

        // Compute cumulative distance along OSRM geometry (to match fraction positions)
        const osrmDist = [0];
        for (let i = 1; i < denseGeom.length; i++) {
            const dx = denseGeom[i][0] - denseGeom[i-1][0];
            const dy = denseGeom[i][1] - denseGeom[i-1][1];
            osrmDist.push(osrmDist[i - 1] + Math.sqrt(dx*dx + dy*dy));
        }
        const totalOsrmDist = osrmDist[osrmDist.length - 1] || 0.000001;

        // Create new points with elevation interpolated from the original GPX section
        let newPoints = denseGeom.map((coord, i) => {
            const fraction = osrmDist[i] / totalOsrmDist;
            return {
                lon: coord[0],
                lat: coord[1],
                ele: interpolateElevation(fraction)
            };
        });

        // Smooth sharp turns further
        newPoints = smoothSharpTurns(newPoints, 20, 3);

        // Replace old segment with new smooth & elevated OSRM geometry
        gpxPoints = [
            ...gpxPoints.slice(0, startIndex),
            ...newPoints,
            ...gpxPoints.slice(endIndex + 1)
        ];

        tgtLayer.clearLayers();

        if (gpxLayer) map.removeLayer(gpxLayer);
        gpxLayer = L.polyline(
            gpxPoints.map(p => [p.lat, p.lon]),
            { color: "green" }
        ).addTo(map);

        // Draw all points for visibility
        drawPointMarkers();

        console.log("OSRM geometry inserted with elevation preservation:", newPoints.length, "points");

    } catch (err) {
        console.error(err);
        alert("Network or OSRM error.");
    } finally {
        document.getElementById('snapPathBtn').disabled = false;
    }
}

document.getElementById('snapBtn').onclick = snapArea;
document.getElementById('snapPathBtn').onclick = snapToExternalPath; 

// Download GPX
function generateGPX(){
    let gpx=`<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="GPX Snap Tool">\n<trk><trkseg>`;
    gpxPoints.forEach(p=> gpx+=`\n<trkpt lat="${p.lat}" lon="${p.lon}"><ele>${p.ele}</ele></trkpt>`);
    gpx+=`\n</trkseg></trk></gpx>`;
    return gpx;
}

document.getElementById('downloadBtn').onclick = ()=>{
    const blob = new Blob([generateGPX()], {type:'application/gpx+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='snapped.gpx'; a.click();
};
  // === Smooth the selected section by replacing sharp turns with curved Bezier arcs ===
function smoothSelectedSection() {
    if (!selectionShape || gpxPoints.length === 0) {
        alert("No selection.");
        return;
    }

    // find indices inside selection
    let indices = gpxPoints
        .map((p,i) => pointInSelection(p) ? i : -1)
        .filter(i => i >= 0);

    if (indices.length < 3) {
        alert("Select at least a short section with multiple points.");
        return;
    }

    indices.sort((a,b)=>a-b);

    const start = indices[0];
    const end   = indices[indices.length-1];

    const section = gpxPoints.slice(start, end+1);

    // ---- Build new smoothed section ----
    let newSection = [];
    const Ncurve = 20;      // number of points per turn curve
    const angThreshold = 40; // angle threshold (deg)

    function angle(a,b,c){
        const abx=b.lon-a.lon, aby=b.lat-a.lat;
        const cbx=b.lon-c.lon, cby=b.lat-c.lat;
        const dot=abx*cbx+aby*cby;
        const mag1=Math.sqrt(abx*abx+aby*aby);
        const mag2=Math.sqrt(cbx*cbx+cby*cby);
        if(!mag1||!mag2) return 180;
        return Math.acos(Math.max(-1,Math.min(1,dot/(mag1*mag2))))*(180/Math.PI);
    }

    function bezier(p0,p1,p2,t){
        const u=1-t;
        return {
            lat: u*u*p0.lat + 2*u*t*p1.lat + t*t*p2.lat,
            lon: u*u*p0.lon + 2*u*t*p1.lon + t*t*p2.lon,
            ele: u*u*p0.ele + 2*u*t*p1.ele + t*t*p2.ele,
        };
    }

    newSection.push(section[0]);

    for (let i=1;i<section.length-1;i++){
        const a = section[i-1];
        const b = section[i];
        const c = section[i+1];

        const ang = angle(a,b,c);

        if (ang < angThreshold){
            // create a Bezier control point slightly toward the outside
            const ctrl = {
                lat: b.lat,
                lon: b.lon,
                ele: b.ele
            };

            // generate curve
            for (let t=0; t<=1; t+=1/Ncurve){
                newSection.push(bezier(a, ctrl, c, t));
            }
        } else {
            newSection.push(b);
        }
    }

    newSection.push(section[section.length-1]);

    // --- Replace original section ---
    gpxPoints = [
        ...gpxPoints.slice(0, start),
        ...newSection,
        ...gpxPoints.slice(end+1)
    ];

    // redraw
    if (gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p=>[p.lat,p.lon]), {color:"purple"}).addTo(map);
    drawPointMarkers();
}
document.getElementById("smoothBtn").onclick = smoothSelectedSection;

</script>
</body>
</html>
