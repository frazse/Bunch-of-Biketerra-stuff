<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>GPX Snap/Align Tool</title>
<style>
  body { font-family: sans-serif; margin:0; padding:0; }
  #map { width: 100%; height: 80vh; border-bottom: 2px solid #ccc; }
  #controls { padding: 10px; }
  button, input { padding: 8px 14px; margin-right:10px; }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="controls">
  <input type="file" id="gpxFile" accept=".gpx"> 
  <button id="snapBtn">Snap Selected Area</button>
  <button id="snapPathBtn">Snap to Path</button>
  <button id="downloadBtn">Download Updated GPX</button>
</div>

<script>
let map = L.map('map').setView([0,0], 2);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let editableLayers = new L.FeatureGroup().addTo(map);
let drawControl = new L.Control.Draw({
    draw: { polygon:true, rectangle:true, polyline:false, circle:false, circlemarker:false, marker:false },
    edit: { featureGroup: editableLayers }
});
map.addControl(drawControl);

let gpxPoints = [], gpxLayer = null, selectionShape = null;
let refLayer = L.layerGroup().addTo(map);
let tgtLayer = L.layerGroup().addTo(map);
let referencePath = []; // for snapToPath

// Helper function to introduce a delay for OSRM rate limiting
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Load GPX
document.getElementById('gpxFile').addEventListener('change', async e => {
    let file = e.target.files[0];
    if (!file) return;
    let text = await file.text();
    loadGPX(text);
});

function loadGPX(gpxText){
    let parser = new DOMParser();
    let xml = parser.parseFromString(gpxText, "application/xml");
    let geo = toGeoJSON.gpx(xml);
    gpxPoints = geo.features[0].geometry.coordinates.map(c => ({ lon:c[0], lat:c[1], ele:c[2]||0 }));
    // ðŸ’¡ CRITICAL: Ensure referencePath is set ONLY ONCE from the original data
    referencePath = gpxPoints.map(p => ({...p})); // Deep copy of points

    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p=>[p.lat,p.lon]), {color:'red'}).addTo(map);
    map.fitBounds(gpxLayer.getBounds());
}

// Draw selection
map.on(L.Draw.Event.CREATED, function(event) {
    if (selectionShape) editableLayers.removeLayer(selectionShape);
    selectionShape = event.layer;
    editableLayers.addLayer(selectionShape);
});

// Check if point is inside selection
function pointInSelection(p){
    if(!selectionShape) return false;
    
    // Handle L.Rectangle (Rectangular selection)
    if(selectionShape instanceof L.Rectangle){
        const b = selectionShape.getBounds();
        return p.lat>=b.getSouth() && p.lat<=b.getNorth() && p.lon>=b.getWest() && p.lon<=b.getEast();
    
    // Handle L.Polygon (Freeform selection)
    } else if(selectionShape instanceof L.Polygon){
        // Get the coordinates of the polygon vertices
        const poly = selectionShape.getLatLngs()[0]; // Assumes a single outer ring
        const x = p.lat, y = p.lon; // Point coordinates
        
        let inside = false;
        
        // Ray-casting algorithm (checks intersections)
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].lat, yi = poly[i].lng;
            const xj = poly[j].lat, yj = poly[j].lng;
            
            // Check if the ray from the point intersects the segment (i, j)
            const intersect = ((yi > y) != (yj > y)) && 
                              (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            
            if(intersect) inside=!inside;
        }
        return inside;
    }
    return false;
}

// Project point onto segment (only used by snapArea now, but kept)
function projectPointOnSegment(p,a,b){
    const ax=a.lon, ay=a.lat, bx=b.lon, by=b.lat, px=p.lon, py=p.lat;
    const abx=bx-ax, aby=by-ay;
    const t=Math.max(0,Math.min(1,((px-ax)*abx+(py-ay)*aby)/(abx*abx+aby*aby)));
    return { lon: ax + t*abx, lat: ay + t*aby, ele: a.ele + t*(b.ele - a.ele) };
}

// Snap selected area (Geometric snap to self - logic remains the same)
function snapArea() {
    if (!selectionShape || gpxPoints.length === 0) return;

    // Get indices of points inside selection
    let insideIndices = gpxPoints.map((p,i) => pointInSelection(p) ? i : -1).filter(i => i >= 0);
    if (insideIndices.length < 2) { alert("Select at least 2 points."); return; }

    // Sort points by cumulative distance along GPX
    const cumDist = [0];
    for (let i = 1; i < gpxPoints.length; i++) {
        const dx = gpxPoints[i].lon - gpxPoints[i-1].lon;
        const dy = gpxPoints[i].lat - gpxPoints[i-1].lat;
        cumDist.push(cumDist[i-1] + Math.sqrt(dx*dx + dy*dy));
    }
    insideIndices.sort((a,b) => cumDist[a] - cumDist[b]);

    // Split into reference (first half) and target (second half)
    const mid = Math.floor(insideIndices.length / 2);
    const refIdx = insideIndices.slice(0, mid);
    const tgtIdx = insideIndices.slice(mid);

    refLayer.clearLayers();
    tgtLayer.clearLayers();

    refIdx.forEach(i => L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon], {radius:4,color:'blue',fillColor:'blue',fillOpacity:0.9}).addTo(refLayer));
    tgtIdx.forEach(i => L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon], {radius:4,color:'orange',fillColor:'orange',fillOpacity:0.9}).addTo(tgtLayer));

    const refPoints = refIdx.map(i => gpxPoints[i]);
    const tgtPoints = tgtIdx.map(i => gpxPoints[i]);

    // Compute cumulative distances along reference
    const refDist = [0];
    for (let i = 1; i < refPoints.length; i++) {
        const dx = refPoints[i].lon - refPoints[i-1].lon;
        const dy = refPoints[i].lat - refPoints[i-1].lat;
        refDist.push(refDist[i-1] + Math.sqrt(dx*dx + dy*dy));
    }

    // --- GEOMETRIC SNAP AND RE-ORDER FIX START ---
    const snappedTargetData = [];

    for (let k = 0; k < tgtPoints.length; k++) {
        const p = tgtPoints[k];
        let bestSnappedPoint = null;
        let bestDistanceSquared = Infinity;
        let snapDistOnRef = 0; 

        for (let j = 0; j < refPoints.length - 1; j++) {
            const a = refPoints[j];
            const b = refPoints[j+1];
            
            const snapped = projectPointOnSegment(p, a, b); 
            
            const dx = snapped.lon - p.lon;
            const dy = snapped.lat - p.lat;
            const distSq = dx * dx + dy * dy;

            if (distSq < bestDistanceSquared) {
                bestDistanceSquared = distSq;
                bestSnappedPoint = snapped;
                
                const distToA = Math.sqrt((snapped.lon - a.lon)**2 + (snapped.lat - a.lat)**2);
                snapDistOnRef = refDist[j] + distToA;
            }
        }
        
        if (bestSnappedPoint) {
            snappedTargetData.push({
                originalIndex: tgtIdx[k],
                snappedPoint: bestSnappedPoint,
                distOnRef: snapDistOnRef
            });
        }
    }

    // 2. Sort the Snapped Target Data by their Position along the Reference Path
    snappedTargetData.sort((a, b) => a.distOnRef - b.distOnRef);

    // 3. Update the Original GPX Points Array using the Sorted Data
    snappedTargetData.forEach((data, k) => {
        const originalGPXIndex = data.originalIndex;
        gpxPoints[originalGPXIndex] = data.snappedPoint;
    });

    // --- GEOMETRIC SNAP AND RE-ORDER FIX END ---

    // Redraw polyline
    if (gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p => [p.lat, p.lon]), {color:'blue'}).addTo(map);
}

// ðŸŸ¢ UPDATED FUNCTION: Snap to External Path using OSRM Match Service
// ðŸŸ¢ NEW VERSION â€” Replaces selected range with dense OSRM geometry
// ðŸŸ¢ NEW VERSION â€” Inserts OSRM geometry AND preserves elevation by interpolation
async function snapToExternalPath() {
    if (!selectionShape || gpxPoints.length === 0) return;

    const indices = gpxPoints
        .map((p, i) => pointInSelection(p) ? i : -1)
        .filter(i => i >= 0);

    if (indices.length === 0) {
        alert("Select at least one point to snap.");
        return;
    }

    indices.sort((a, b) => a - b);
    const startIndex = indices[0];
    const endIndex   = indices[indices.length - 1];

    // Extract the elevation source segment
    const originalSegment = gpxPoints.slice(startIndex, endIndex + 1);

    // Precompute cumulative distance in the original segment (for elevation interpolation)
    const origDist = [0];
    for (let i = 1; i < originalSegment.length; i++) {
        const dx = originalSegment[i].lon - originalSegment[i-1].lon;
        const dy = originalSegment[i].lat - originalSegment[i-1].lat;
        origDist.push(origDist[i - 1] + Math.sqrt(dx*dx + dy*dy));
    }
    const totalOrigDist = origDist[origDist.length - 1];

    // Function to interpolate elevation based on distance fraction
    function interpolateElevation(fraction) {
        if (fraction <= 0) return originalSegment[0].ele;
        if (fraction >= 1) return originalSegment[originalSegment.length - 1].ele;

        const targetDist = fraction * totalOrigDist;

        // find segment
        for (let i = 0; i < origDist.length - 1; i++) {
            if (origDist[i] <= targetDist && origDist[i+1] >= targetDist) {
                const span = origDist[i+1] - origDist[i];
                const localF = (targetDist - origDist[i]) / span;
                return originalSegment[i].ele +
                       localF * (originalSegment[i+1].ele - originalSegment[i].ele);
            }
        }

        return originalSegment[originalSegment.length - 1].ele;
    }

    // Build OSRM coordinate string
    const coordinatesString = indices
        .map(i => `${gpxPoints[i].lon},${gpxPoints[i].lat}`)
        .join(';');

    const OSRM_URL =
        `https://router.project-osrm.org/match/v1/driving/` +
        `${coordinatesString}?overview=full&geometries=geojson&tidy=true`;

    document.getElementById('snapPathBtn').disabled = true;

    try {
        const response = await fetch(OSRM_URL);
        const data = await response.json();

        if (data.code !== "Ok" || !data.matchings || data.matchings.length === 0) {
            alert("Map matching failed.");
            console.log(data);
            return;
        }

        // Full OSRM geometry (lon, lat)
        const denseGeom = data.matchings[0].geometry.coordinates;

        // Compute cumulative distance along OSRM geometry (to match fraction positions)
        const osrmDist = [0];
        for (let i = 1; i < denseGeom.length; i++) {
            const dx = denseGeom[i][0] - denseGeom[i-1][0];
            const dy = denseGeom[i][1] - denseGeom[i-1][1];
            osrmDist.push(osrmDist[i - 1] + Math.sqrt(dx*dx + dy*dy));
        }
        const totalOsrmDist = osrmDist[osrmDist.length - 1];

        // Create new points with elevation interpolated from the original GPX section
        const newPoints = denseGeom.map((coord, i) => {
            const fraction = osrmDist[i] / totalOsrmDist;
            return {
                lon: coord[0],
                lat: coord[1],
                ele: interpolateElevation(fraction)
            };
        });

        // Replace old segment with new smooth & elevated OSRM geometry
        gpxPoints = [
            ...gpxPoints.slice(0, startIndex),
            ...newPoints,
            ...gpxPoints.slice(endIndex + 1)
        ];

        tgtLayer.clearLayers();

        if (gpxLayer) map.removeLayer(gpxLayer);
gpxLayer = L.polyline(
    gpxPoints.map(p => [p.lat, p.lon]),
    { color: "green" }
).addTo(map);
drawPointMarkers();

        console.log("OSRM geometry inserted with elevation preservation:", newPoints.length, "points");

    } catch (err) {
        console.error(err);
        alert("Network or OSRM error.");
    } finally {
        document.getElementById('snapPathBtn').disabled = false;
    }
}

// Densify path (No longer used by external snap, but kept for completeness)
function densifyPath(points, step=0.00001){
    const densified=[];
    for(let i=0;i<points.length-1;i++){
        const a=points[i], b=points[i+1];
        const dx=b.lon-a.lon, dy=b.lat-a.lat, dz=b.ele-a.ele;
        const dist=Math.sqrt(dx*dx+dy*dy);
        const n=Math.ceil(dist/step);
        for(let j=0;j<n;j++){
            densified.push({lat:a.lat + dy*j/n, lon:a.lon + dx*j/n, ele:a.ele + dz*j/n});
        }
    }
    densified.push(points[points.length-1]);
    return densified;
}

document.getElementById('snapBtn').onclick = snapArea;
// ðŸ’¡ IMPORTANT: Update the snapPathBtn to use the new external snapping function
document.getElementById('snapPathBtn').onclick = snapToExternalPath; 

// Download GPX
function generateGPX(){
    let gpx=`<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="GPX Snap Tool">\n<trk><trkseg>`;
    gpxPoints.forEach(p=> gpx+=`\n<trkpt lat="${p.lat}" lon="${p.lon}"><ele>${p.ele}</ele></trkpt>`);
    gpx+=`\n</trkseg></trk></gpx>`;
    return gpx;
}

document.getElementById('downloadBtn').onclick = ()=>{
    const blob = new Blob([generateGPX()], {type:'application/gpx+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='snapped.gpx'; a.click();
};
</script></html>
