<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>GPX Snap/Align Tool</title>
<style>
  body { font-family: sans-serif; margin:0; padding:0; }
  #map { width: 100%; height: 80vh; border-bottom: 2px solid #ccc; }
  #controls { padding: 10px; }
  button, input { padding: 8px 14px; margin-right:10px; }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="controls">
  <input type="file" id="gpxFile" accept=".gpx"> 
  <button id="snapBtn">Snap Selected Area</button>
  <button id="snapPathBtn">Snap to Path</button>
  <button id="downloadBtn">Download Updated GPX</button>
</div>

<script>
let map = L.map('map').setView([0,0], 2);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let editableLayers = new L.FeatureGroup().addTo(map);
let drawControl = new L.Control.Draw({
    draw: { polygon:true, rectangle:true, polyline:false, circle:false, circlemarker:false, marker:false },
    edit: { featureGroup: editableLayers }
});
map.addControl(drawControl);

let gpxPoints = [], gpxLayer = null, selectionShape = null;
let refLayer = L.layerGroup().addTo(map);
let tgtLayer = L.layerGroup().addTo(map);
let referencePath = [];

// Load GPX
document.getElementById('gpxFile').addEventListener('change', async e => {
    let file = e.target.files[0];
    if (!file) return;
    let text = await file.text();
    loadGPX(text);
});

function loadGPX(gpxText){
    let parser = new DOMParser();
    let xml = parser.parseFromString(gpxText, "application/xml");
    let geo = toGeoJSON.gpx(xml);
    gpxPoints = geo.features[0].geometry.coordinates.map(c => ({ lon:c[0], lat:c[1], ele:c[2]||0 }));
    referencePath = gpxPoints.map(p => ({...p}));

    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p=>[p.lat,p.lon]), {color:'red'}).addTo(map);
    map.fitBounds(gpxLayer.getBounds());
}

// Draw selection
map.on(L.Draw.Event.CREATED, function(event) {
    if (selectionShape) editableLayers.removeLayer(selectionShape);
    selectionShape = event.layer;
    editableLayers.addLayer(selectionShape);
});

// Check if point is inside selection
function pointInSelection(p){
    if(!selectionShape) return false;
    if(selectionShape instanceof L.Rectangle){
        const b = selectionShape.getBounds();
        return p.lat>=b.getSouth() && p.lat<=b.getNorth() && p.lon>=b.getWest() && p.lon<=b.getEast();
    } else if(selectionShape instanceof L.Polygon){
        const poly = selectionShape.getLatLngs()[0];
        const x = p.lat, y = p.lon;
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].lat, yi = poly[i].lng;
            const xj = poly[j].lat, yj = poly[j].lng;
            const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if(intersect) inside=!inside;
        }
        return inside;
    }
    return false;
}

// Densify path
function densifyPath(points, step=0.00001){
    const densified=[];
    for(let i=0;i<points.length-1;i++){
        const a=points[i], b=points[i+1];
        const dx=b.lon-a.lon, dy=b.lat-a.lat, dz=b.ele-a.ele;
        const dist=Math.sqrt(dx*dx+dy*dy);
        const n=Math.ceil(dist/step);
        for(let j=0;j<n;j++){
            densified.push({lat:a.lat + dy*j/n, lon:a.lon + dx*j/n, ele:a.ele + dz*j/n});
        }
    }
    densified.push(points[points.length-1]);
    return densified;
}

// Interpolate along path by fraction
function interpolateAlongPath(path, fraction){
    const cumDist = [0];
    for(let i=1;i<path.length;i++){
        const dx = path[i].lon - path[i-1].lon;
        const dy = path[i].lat - path[i-1].lat;
        cumDist.push(cumDist[i-1] + Math.sqrt(dx*dx + dy*dy));
    }
    const totalDist = cumDist[cumDist.length-1];
    const targetDist = fraction * totalDist;

    for(let i=1;i<path.length;i++){
        const segDist = cumDist[i]-cumDist[i-1];
        if(cumDist[i-1]<=targetDist && targetDist<=cumDist[i]){
            const t = (targetDist-cumDist[i-1])/segDist;
            return {
                lat: path[i-1].lat + t*(path[i].lat-path[i-1].lat),
                lon: path[i-1].lon + t*(path[i].lon-path[i-1].lon),
                ele: path[i-1].ele + t*(path[i].ele-path[i-1].ele)
            };
        }
    }
    return path[path.length-1];
}

// --- SNAP SELECTED AREA WITH EXACT ALIGNMENT ---
function snapAreaExact(){
    if (!selectionShape || gpxPoints.length===0) return;
    let insideIndices = gpxPoints.map((p,i)=>pointInSelection(p)?i:-1).filter(i=>i>=0);
    if(insideIndices.length<2){ alert("Select at least 2 points."); return; }

    const mid = Math.floor(insideIndices.length/2);
    const refIdx = insideIndices.slice(0,mid);
    const tgtIdx = insideIndices.slice(mid);

    refLayer.clearLayers(); tgtLayer.clearLayers();

    refIdx.forEach(i=>L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon],{radius:4,color:'blue',fillColor:'blue',fillOpacity:0.9}).addTo(refLayer));
    tgtIdx.forEach(i=>L.circleMarker([gpxPoints[i].lat,gpxPoints[i].lon],{radius:4,color:'orange',fillColor:'orange',fillOpacity:0.9}).addTo(tgtLayer));

    const refPoints = refIdx.map(i=>gpxPoints[i]);
    const tgtPoints = tgtIdx.map(i=>gpxPoints[i]);

    const densifiedRef = densifyPath(refPoints,0.00001);

    const n = tgtPoints.length;
    const fractions = tgtPoints.map((_,k)=>(k+1)/(n+1));

    fractions.forEach((f,k)=>{
        const idx = tgtIdx[k];
        gpxPoints[idx] = interpolateAlongPath(densifiedRef,f);
    });

    if(gpxLayer) map.removeLayer(gpxLayer);
    gpxLayer = L.polyline(gpxPoints.map(p=>[p.lat,p.lon]),{color:'blue'}).addTo(map);
}

// --- SNAP TO EXTERNAL PATH USING OSRM ---
async function snapToExternalPath() {
    if (!selectionShape || gpxPoints.length === 0) return;
    const indices = gpxPoints.map((p, i) => pointInSelection(p) ? i : -1).filter(i => i >= 0);
    if (indices.length === 0) { alert("Select at least one point to snap."); return; }

    tgtLayer.clearLayers();
    indices.sort((a, b) => a - b);

    const coordinatesString = indices.map(i => `${gpxPoints[i].lon},${gpxPoints[i].lat}`).join(';');
    const OSRM_URL = `https://router.project-osrm.org/match/v1/driving/${coordinatesString}?overview=full&geometries=geojson`;

    document.getElementById('snapPathBtn').disabled = true;

    try {
        const response = await fetch(OSRM_URL);
        const data = await response.json();
        if (data.code === 'Ok' && data.tracepoints && data.matchings.length > 0) {
            data.tracepoints.forEach((tp, k) => {
                if (tp !== null) {
                    const originalIndex = indices[k];
                    const snappedCoord = tp.location;
                    gpxPoints[originalIndex].lon = snappedCoord[0];
                    gpxPoints[originalIndex].lat = snappedCoord[1];
                    L.circleMarker([gpxPoints[originalIndex].lat, gpxPoints[originalIndex].lon], { radius: 4, color: 'green', fillColor: 'green', fillOpacity: 0.9 }).addTo(tgtLayer);
                }
            });
            if (gpxLayer) map.removeLayer(gpxLayer);
            gpxLayer = L.polyline(gpxPoints.map(p => [p.lat, p.lon]), { color: 'green' }).addTo(map);
        } else {
            alert(`Snapping failed: OSRM returned code ${data.code}`);
        }
    } catch (error) { console.error(error); alert("Error during OSRM API call."); }
    finally { document.getElementById('snapPathBtn').disabled = false; }
}

// --- GENERATE AND DOWNLOAD GPX ---
function generateGPX(){
    let gpx=`<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="GPX Snap Tool">\n<trk><trkseg>`;
    gpxPoints.forEach(p=> gpx+=`\n<trkpt lat="${p.lat}" lon="${p.lon}"><ele>${p.ele}</ele></trkpt>`);
    gpx+=`\n</trkseg></trk></gpx>`;
    return gpx;
}

document.getElementById('snapBtn').onclick = snapAreaExact;
document.getElementById('snapPathBtn').onclick = snapToExternalPath; 
document.getElementById('downloadBtn').onclick = ()=>{
    const blob = new Blob([generateGPX()], {type:'application/gpx+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='snapped.gpx'; a.click();
};
</script>
</body>
</html>
