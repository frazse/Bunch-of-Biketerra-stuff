// ==UserScript==
// @name         Biketerra LeaderOverlay
// @namespace    http://tampermonkey.net/
// @version      1.4
// @description  Shows the leader's position on the elevation graph using .elev-cursor + Manual route/climb options + Toggle settings menu
// @author       Josef
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function () {
    'use strict';
    console.log("[Leader Overlay] Script started");

    const checkInterval = 500;

    let manualRouteLength = null;
    let manualTotalClimb = null;
    let autoDetect = true;

    let routeLength = 0;
    let overlay, logContainer, startLine, endLine, leaderLine, myPosLine;
    let settingsBox = null;
    let gearButton = null;

    let currentMyX = 0, currentLeaderX = 0;

    // ============================
    //      SETTINGS BOX
    // ============================
    function createSettingsBox() {
        if (settingsBox) return settingsBox;

        settingsBox = document.createElement("div");
        Object.assign(settingsBox.style, {
            position: "fixed",
            top: "10px",
            left: "10px",
            padding: "10px",
            background: "rgba(0,0,0,0.8)",
            color: "white",
            fontSize: "12px",
            borderRadius: "6px",
            zIndex: 99999,
            display: "none"
        });

        settingsBox.innerHTML = `
            <b>LeaderOverlay Settings</b><br>
            <label>
                <input type="checkbox" id="autoDetectChk" checked>
                Auto detect
            </label><br><br>
            Route length (km):<br>
            <input id="manualRoute" type="number" step="0.1" style="width:120px"><br><br>

            Total climb (m):<br>
            <input id="manualClimb" type="number" step="1" style="width:120px"><br><br>

            <button id="applyOverlaySettings">Apply</button>
        `;

        document.body.appendChild(settingsBox);

        document.getElementById("applyOverlaySettings").onclick = () => {
            autoDetect = document.getElementById("autoDetectChk").checked;

            const mr = parseFloat(document.getElementById("manualRoute").value);
            const mc = parseFloat(document.getElementById("manualClimb").value);

            manualRouteLength = isNaN(mr) ? null : mr;
            manualTotalClimb = isNaN(mc) ? null : mc;

            if (manualRouteLength !== null) {
                routeLength = manualRouteLength;
                console.log("[LeaderOverlay] Manual route length applied:", routeLength);
            }

            console.log("[LeaderOverlay] Settings updated", {
                autoDetect,
                manualRouteLength,
                manualTotalClimb
            });
        };

        return settingsBox;
    }

    // ============================
    //       OVERLAY WINDOW
    // ============================
    function createOverlay() {
        if (overlay) return overlay;

        overlay = document.createElement('div');
        overlay.id = 'leaderOverlay';
        Object.assign(overlay.style, {
            position: 'fixed',
            bottom: '8px',
            left: '50%',
            transform: 'translateX(-50%)',
            width: '50vw',
            height: '95px',
            background: 'rgba(0,0,0,0.0)',
            zIndex: '9999',
            borderRadius: '6px',
            cursor: 'default',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            overflow: 'hidden'
        });
        document.body.appendChild(overlay);

        // Small menu button
        gearButton = document.createElement("div");
        gearButton.textContent = "☰";
        Object.assign(gearButton.style, {
            position: "absolute",
            top: "2px",
            right: "2px",
            cursor: "pointer",
            color: "rgba(255,255,255,0.5)",
            fontSize: "12px",
            padding: "2px 6px",
            borderRadius: "4px",
            userSelect: "none",
            zIndex: 10000
        });

        overlay.appendChild(gearButton);

        gearButton.onclick = () => {
            const box = createSettingsBox();
            box.style.display = (box.style.display === "none") ? "block" : "none";
        };

        // Log container
        logContainer = document.createElement("div");
        Object.assign(logContainer.style, {
            width: "100%",
            fontSize: "12px",
            color: "white",
            textAlign: "center"
        });
        overlay.appendChild(logContainer);

        // SVG Graph
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "80%");
        overlay.appendChild(svg);

        const height = overlay.clientHeight * 0.8;

        startLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        startLine.setAttribute("stroke", "white");
        startLine.setAttribute("stroke-width", 0);
        svg.appendChild(startLine);

        endLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        endLine.setAttribute("stroke", "white");
        endLine.setAttribute("stroke-width", 0);
        svg.appendChild(endLine);

        myPosLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        myPosLine.setAttribute("y1", 0);
        myPosLine.setAttribute("y2", height);
        myPosLine.setAttribute("stroke", "lime");
        myPosLine.setAttribute("stroke-width", 2);
        svg.appendChild(myPosLine);

        leaderLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        leaderLine.setAttribute("y1", 0);
        leaderLine.setAttribute("y2", height);
        leaderLine.setAttribute("stroke", "red");
        leaderLine.setAttribute("stroke-width", 2);
        svg.appendChild(leaderLine);

        return overlay;
    }

    // ============================
    //       POSITION READER
    // ============================
function getLeaderAndMyPos() {
    let leaderPercent = null;

    // My position via .elev-cursor
    let myPercent = 0;
    const cursor = document.querySelector('.elev-cursor');
    if (cursor) {
        const match = cursor.style.left.match(/([\d.]+)%/);
        if (match) myPercent = parseFloat(match[1]);
    }

    // Auto-detect route length
    if (autoDetect && routeLength === 0 && manualRouteLength === null) {
        const statsGrid = document.querySelector(".stats-grid");
        if (statsGrid) {
            const rows = statsGrid.querySelectorAll(".stat-row.svelte-1wfcwp8");
            if (rows.length >= 3) {
                const valEl = rows[2].querySelector(".avg-value.svelte-1wfcwp8");
                if (valEl) routeLength = parseFloat(valEl.textContent.trim()) || 0;
            }
        }
    }

    // Leader logic
    const ridersMain = document.querySelector(".riders-main");

    if (!ridersMain) {
        // Rider list missing → you are the leader
        leaderPercent = myPercent;
    } else {
        const firstRider = ridersMain.querySelector(".rider");
        if (!firstRider) {
            // No riders in list → you are the leader
            leaderPercent = myPercent;
        } else {
            const nameEl = firstRider.querySelector(".rider-name");
            const distEl = firstRider.querySelector(".rider-distance .monospace");

            if (nameEl && (nameEl.textContent.trim().toLowerCase() === "you" || nameEl.textContent.trim().toLowerCase().includes("spectating"))) {
                leaderPercent = myPercent;
            } else if (distEl && routeLength > 0) {
                let numberText = distEl.textContent.trim();
                let unitText = "km";

                let nextNode = distEl.nextSibling;
                while (nextNode) {
                    if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim()) {
                        unitText = nextNode.textContent.trim().toLowerCase();
                        break;
                    }
                    nextNode = nextNode.nextSibling;
                }

                let value = parseFloat(numberText) || 0;
                if (unitText.includes("meter")) value /= 1000;

                leaderPercent = (value / routeLength) * 100;
            } else {
                // fallback
                leaderPercent = myPercent;
            }
        }
    }

    return { leaderPercent, myPercent };
}

function updateOverlay() {
    const overlay = createOverlay();
    const pos = getLeaderAndMyPos();

    if (!routeLength) return; // wait until route length known

    const width = overlay.clientWidth;

    // Smooth animation
    currentMyX += ((pos.myPercent / 100) * width - currentMyX) * 0.6;
    currentLeaderX += ((pos.leaderPercent / 100) * width - currentLeaderX) * 0.6;

    myPosLine.setAttribute("x1", currentMyX);
    myPosLine.setAttribute("x2", currentMyX);

    leaderLine.setAttribute("x1", currentLeaderX);
    leaderLine.setAttribute("x2", currentLeaderX);

    //logContainer.textContent = `Leader=${pos.leaderPercent.toFixed(2)}% | You=${pos.myPercent.toFixed(2)}% | Route=${routeLength} km`;
}


    setInterval(updateOverlay, checkInterval);

})();
