// ==UserScript==
// @name         Biketerra LeaderOverlay + Climbs (block on workout)
// @namespace    http://tampermonkey.net/
// @version      1.2
// @description  K√∂r endast om .workout-wrap INTE finns, g√∂m overlays om den dyker upp
// @match        https://biketerra.com/ride*
// @grant        none
// ==/UserScript==

(function() {

    // Kontrollera om workout-wrap finns
    if(document.querySelector(".workout-wrap")) {
        console.log("‚ùå workout-wrap finns ‚Äì script blockerat");
        return; // STOPP: k√∂r inte scriptet
    }

    console.log("üèÅ Script initierat ‚Äì workout-wrap saknas");

// ==UserScript==
// @name         Biketerra LeaderOverlay + Climbs
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Leader overlay + climbs + flats + segment list - merge climbs <0.25km appart and include short flats between climbs; correct height calculation (counts all positive dy)
// @author       Josef N/Chatgpt
// @match        https://biketerra.com/ride*
// @match        https://biketerra.com/spectate/*
// @exclude      https://biketerra.com/dashboard
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';
    console.log("[Leader Overlay] Merge+Height v1 started");

function createManualRouteSettings() {
    const container = document.createElement('div');
    container.style.cssText += 'display: none !important;';

    container.id = 'manualRouteContainer';
    Object.assign(container.style, {
        position:'fixed',
        top:'10px',
        left:'50%',
        transform:'translateX(-50%)',
        background:'#000c',
        padding:'6px 12px',
        borderRadius:'6px',
        color:'white',
        fontSize:'12px',
        zIndex:'9999',
        gap:'6px',
        alignItems:'center',
        display:'none' // s√§tt display sist s√• inget √∂verskriver
    });


    const lengthInput = document.createElement('input');
    lengthInput.type = 'number';
    lengthInput.min = '0';
    lengthInput.step = '0.1';
    lengthInput.placeholder = 'Route km';
    lengthInput.style.width = '60px';

    const climbInput = document.createElement('input');
    climbInput.type = 'number';
    climbInput.min = '0';
    climbInput.step = '1';
    climbInput.placeholder = 'Climb m';
    climbInput.style.width = '60px';

    const btn = document.createElement('button');
    btn.textContent = 'Set';
    Object.assign(btn.style, {cursor:'pointer', padding:'2px 6px', fontSize:'12px'});

    btn.addEventListener('click', () => {
        const len = parseFloat(lengthInput.value);
        const climb = parseFloat(climbInput.value);
        if(!isNaN(len) && len > 0) routeLength = len;
        if(!isNaN(climb) && climb > 0) totalClimb = climb;
        console.log('[Manual Route] Length:', routeLength, 'km, Climb:', totalClimb, 'm');

        // --- Reset flags for rebuild ---
        segmentListBuilt = false;
        window.currentClimbIndex = -1;
        window.currentClimbStartTime = null;
        window.climbFinishedTime = null;

        // --- Compute primitives and scale ---
        let primitives = computePrimitives();
        if(primitives.length){
            let totalPosY = primitives.reduce((sum,p) => sum + (p.dyM>0?p.dyM:0),0);
            const scale = totalPosY>0 ? (totalClimb / totalPosY) : 1;

            primitives.forEach(p => {
                p.dxKm = (p.end - p.start) * routeLength;
                p.dyM *= scale;
                p.avgSlope = (p.dxKm>0) ? (p.dyM / (p.dxKm*1000))*100 : 0;

                // grade
                if(p.avgSlope >= 40) p.grade='a';
                else if(p.avgSlope >= 20) p.grade='b';
                else if(p.avgSlope >= 10) p.grade='c';
                else if(p.avgSlope >= 5)  p.grade='d';
                else if(p.avgSlope>0)      p.grade='e';
                else                       p.grade='flat';
            });
        }

        // --- Build blocks & merge climbs ---
        const blocks = buildBlocks(primitives);
        const mergedClimbs = mergeClimbsAndShortFlats(blocks);

        // --- Draw segments (build segmentlist again) ---
        drawSegments(mergedClimbs, primitives);

        // --- Update climb progress ---
        const pos = getLeaderAndMyPos(false);

     let climbsToShow = mergedClimbs.filter(c => c.avgSlope >= DISPLAY_SLOPE_THRESHOLD);

// Hitta climb d√§r vi √§r just nu
const activeClimb = mergedClimbs.find(c => {
    const climbStartInv = routeLength - c.start * routeLength;
    const climbEndInv = routeLength - c.end * routeLength;
    return pos.myPosKm <= climbStartInv && pos.myPosKm >= climbEndInv;
});

// L√§gg alltid till activeClimb om vi befinner oss p√• den
if(activeClimb && !climbsToShow.includes(activeClimb)){
    climbsToShow.unshift(activeClimb);
}


        updateClimbProgress(mergedClimbs, pos.myPosKm);

        // --- Move climb progress overlay above segment list ---
        if(window.climbProgressOverlay && segmentListOverlay){
            const rect = segmentListOverlay.getBoundingClientRect();
            window.climbProgressOverlay.style.bottom = `${window.innerHeight - rect.top + 8}px`;
        }
    });

    container.appendChild(lengthInput);
    container.appendChild(climbInput);
    container.appendChild(btn);
    document.body.appendChild(container);
}
    let maxMyPosKmSeen = 0; // h√∂gsta position vi sett under k√∂rning
function rebuildSegmentList(mergedClimbs, primitives) {
    // skapa overlay om den inte finns
    if (!segmentListOverlay) createSegmentListOverlay();
    if (!segmentListContainer) createSegmentListOverlay();

    // tvinga rebuild
    segmentListContainer.innerHTML = '';

    let displayIndex = 1;
    for (let m of mergedClimbs) {
        if (m.avgSlope < DISPLAY_SLOPE_THRESHOLD) continue;

        const startKm = (m.start * routeLength) || 0;
        const endKm = (m.end * routeLength) || 0;
        const lenKm = Math.max(0, endKm - startKm);

        const div = document.createElement('div');
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.padding = '4px 0';
        div.style.borderBottom = '1px dashed rgba(255,255,255,0.04)';
        div.style.whiteSpace = 'nowrap';
        div.style.overflow = 'hidden';
        div.style.textOverflow = 'ellipsis';

        const colStyle = 'flex:1; text-align:right; overflow:hidden; text-overflow:ellipsis;';

        div.innerHTML = `
            <div style="flex:1; text-align:left;">#${displayIndex} CLIMB</div>
            <div style="${colStyle}">${startKm.toFixed(2)}‚Üí${endKm.toFixed(2)} km</div>
            <div style="${colStyle}">${lenKm.toFixed(2)} km</div>
            <div style="${colStyle}">${m.dyM.toFixed(0)} m</div>
            <div style="${colStyle}">${m.avgSlope.toFixed(2)}%</div>
        `;
        segmentListContainer.appendChild(div);

        displayIndex++;
    }
}
function autoUpdateSegmentList(pos) {
    if (!routeLength) return;

    const primitives = computePrimitives();
    const blocks = buildBlocks(primitives);
    const mergedClimbs = mergeClimbsAndShortFlats(blocks);

    // Bygg segmentlistan alltid
    segmentListBuilt = false;
    drawSegments(mergedClimbs, primitives);
    segmentListBuilt = true;

    // Uppdatera climb progress
    updateClimbProgress(mergedClimbs, pos.myPosKm);
}

function autoUpdateIfReachedMax(pos) {
    if(pos.myPosKm >= routeLength && pos.myPosKm > maxMyPosKmSeen) {
        maxMyPosKmSeen = pos.myPosKm;
        console.log("[Auto Update] myPosKm >= routeLength, k√∂r uppdatering");

        // --- Reset flags for rebuild ---
        window.currentClimbIndex = -1;
        window.currentClimbStartTime = null;
        window.climbFinishedTime = null;

        const primitives = computePrimitives();
        if(primitives.length){
            let totalPosY = primitives.reduce((sum,p) => sum + (p.dyM>0?p.dyM:0),0);
            const scale = totalClimb / totalPosY;
            primitives.forEach(p => {
                p.dxKm = (p.end - p.start) * routeLength;
                p.dyM *= scale;
                p.avgSlope = (p.dxKm>0) ? (p.dyM / (p.dxKm*1000))*100 : 0;
            });
        }

        const blocks = buildBlocks(primitives);
        const mergedClimbs = mergeClimbsAndShortFlats(blocks);

        // --- Tempor√§rt tvinga segmentlistan att byggas ---
        const oldFlag = segmentListBuilt;
        segmentListBuilt = false;
        drawSegments(mergedClimbs, primitives); // bygger listan
        segmentListBuilt = true; // s√§tt tillbaka flaggan

rebuildSegmentList(mergedClimbs, primitives);
updateClimbProgress(mergedClimbs, pos.myPosKm);
    }
}

    const checkInterval = 500; // ms
    const MERGE_GAP_KM = 0.25; // merge threshold
    const DISPLAY_SLOPE_THRESHOLD = 2.5; // % - climbs under this are not shown but counted in height

    let routeLength = 0; // km (detected from page)
    let totalClimb = 0; // meter (detected from page)

    let overlay, logContainer, leaderLine, myPosLine;
    let segmentListOverlay, segmentListContainer;
    let currentMyX = 0, currentLeaderX = 0;
    let segmentRects = [];

    const gradeColors = {
        a: '#FF6262', b: '#DC5666', c: '#B14674', d: '#7F347C', e: '#572667',
        flat: '#0008'
    };
    function getGradeColor(grade) { return gradeColors[grade] || '#ffffff'; }

    // --- Read UI positions / route stats
    function getLeaderAndMyPos(log=false) {
        let leaderKm = 0;
        const ridersMain = document.querySelector('.riders-main');
        if (ridersMain) {
            const firstRider = ridersMain.querySelector('.rider');
            if (firstRider) {
                const leaderDistanceEl = firstRider.querySelector('.rider-distance .monospace');
                if (leaderDistanceEl) {
                    const numberText = leaderDistanceEl.textContent.trim();
                    let unitText = 'km';
                    let nextNode = leaderDistanceEl.nextSibling;
                    while (nextNode) {
                        if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() !== '') {
                            unitText = nextNode.textContent.trim().toLowerCase();
                            break;
                        }
                        nextNode = nextNode.nextSibling;
                    }
                    let value = parseFloat(numberText) || 0;
                    if (unitText.includes('meter')) value /= 1000;
                    leaderKm = numberText.startsWith('-') ? -value : value;
                }
            }
        }

        let myPosKm = 0;
        const statsGrid = document.querySelector('.stats-grid');
        if (statsGrid) {
            const statRows = statsGrid.querySelectorAll('.stat-row.svelte-1wfcwp8');
            if (statRows.length >= 4) {
                const avgValueEl = statRows[2].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
                if (avgValueEl) {
                    myPosKm = parseFloat(avgValueEl.textContent.trim()) || 0;
                    if (routeLength === 0 && myPosKm > 0) {
                        routeLength = myPosKm;
                        if(log) console.log("[DEBUG] Route length detected:", routeLength, "km");
                    }
                }
                const climbValueEl = statRows[3].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
                if (climbValueEl) {
                    const climbText = climbValueEl.textContent.trim();
                    let climbUnit = 'm';
                    let nextNode = climbValueEl.nextSibling;
                    while(nextNode) {
                        if(nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() !== '') {
                            climbUnit = nextNode.textContent.trim().toLowerCase();
                            break;
                        }
                        nextNode = nextNode.nextSibling;
                    }
                    let value = parseFloat(climbText) || 0;
                    if(climbUnit.includes('km')) value *= 1000;
                    totalClimb = value;
                    if(log) console.log("[DEBUG] Total climb detected:", totalClimb, "m");
                }
            }
        }

        if (log) console.log("[DEBUG] LeaderKm:", leaderKm, "MyPosKm:", myPosKm, "TotalClimb:", totalClimb);
        return { leaderKm, myPosKm };
    }

    // --- Overlay UI creation
function createOverlay() {
    if(overlay) return overlay;

    // --- Skapa overlay f√∂rst ---
    overlay = document.createElement('div');
    Object.assign(overlay.style,{
        position:'fixed',
        bottom:'8px',
        left:'50%',
        transform:'translateX(-50%)',
        width:'50vw',
        height:'95px',
        background:'rgba(0,0,0,0.0)',
        zIndex:'9999',
        border:'1px solid rgba(255,255,255,0.05)',
        borderRadius:'6px',
        cursor:'default',
        display:'flex',
        flexDirection:'column',
        alignItems:'center',
        justifyContent:'center',
        overflow:'hidden',
        color: 'white'
    });
    document.body.appendChild(overlay);

    // --- Log container ---
    logContainer = document.createElement('div');
    Object.assign(logContainer.style,{
        flex:'1',
        width:'100%',
        fontSize:'12px',
        color:'white',
        overflowY:'auto',
        textAlign:'center'
    });
    overlay.appendChild(logContainer);

    // --- SVG f√∂r linjer ---
    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute('width','100%');
    svg.setAttribute('height','100%');
    overlay.appendChild(svg);

    const height = overlay.clientHeight * 0.8;

    myPosLine = document.createElementNS("http://www.w3.org/2000/svg","line");
    myPosLine.setAttribute('y1',0);
    myPosLine.setAttribute('y2',height);
    myPosLine.setAttribute('stroke','lime');
    myPosLine.setAttribute('stroke-width',0);
    svg.appendChild(myPosLine);

    leaderLine = document.createElementNS("http://www.w3.org/2000/svg","line");
    leaderLine.setAttribute('y1',0);
    leaderLine.setAttribute('y2',height);
    leaderLine.setAttribute('stroke','red');
    leaderLine.setAttribute('stroke-width',2);
    svg.appendChild(leaderLine);

    // --- Hamburger-meny knapp ---
    const menuBtn = document.createElement('div');
    menuBtn.textContent = '‚ò∞';
    Object.assign(menuBtn.style, {
        position: 'absolute',
        top: '2px',
        left: '4px',
        cursor: 'pointer',
        fontSize: '12px',
        color: 'lightgrey',
        userSelect: 'none'
    });

    menuBtn.addEventListener('click', () => {
        const container = document.getElementById('manualRouteContainer');
        if(container){
            container.style.display = (container.style.display === 'none') ? 'flex' : 'none';
        }
    });

    overlay.appendChild(menuBtn);

    return overlay;
}

    function createSegmentListOverlay() {
        if(segmentListOverlay) return segmentListOverlay;
        segmentListOverlay = document.createElement('div');
        Object.assign(segmentListOverlay.style,{
            position:'fixed', bottom:'111px', left:'50%', transform:'translateX(-50%)',
            width:'32vw', maxHeight:'320px', overflowY:'auto',
            background:'#000a', color:'white', fontSize:'12px', border:'1px solid rgba(255,255,255,0.08)',
            borderRadius:'6px', padding:'6px', zIndex:'9999'
        });
        document.body.appendChild(segmentListOverlay);
        segmentListContainer = document.createElement('div');
        segmentListOverlay.appendChild(segmentListContainer);
        return segmentListOverlay;
    }

    function findMainPolyline() {
        const svg = document.querySelector('svg.pathSVG');
        if(!svg) return null;
        const all = Array.from(svg.querySelectorAll('polyline'));
        if(!all.length) return null;
        return all.sort((a,b)=>{
            const la = (a.getAttribute('points')||'').split(' ').length;
            const lb = (b.getAttribute('points')||'').split(' ').length;
            return lb - la;
        })[0] || null;
    }

    function parsePoints(pointsAttr) {
        if(!pointsAttr) return [];
        return pointsAttr.split(' ')
            .filter(Boolean)
            .map(pt => {
                const [x,y] = pt.split(',').map(Number);
                return {x,y};
            });
    }

    // --- Compute primitive segments (no merge) but with correct real height scaling ---
    function computePrimitives() {
        if(!routeLength || !totalClimb) return [];
        const mainPL = findMainPolyline();
        if(!mainPL) return [];
        const points = parsePoints(mainPL.getAttribute('points'));
        if(!points.length) return [];

        // compute total positive Y (in polyline coordinate units)
        let totalPosY = 0;
        for (let i = 1; i < points.length; i++) {
            const dy = points[i-1].y - points[i].y;
            if (dy > 0) totalPosY += dy;
        }
        const scale = totalPosY > 0 ? (totalClimb / totalPosY) : 0;

        const primitives = [];
        for (let i = 1; i < points.length; i++) {
            const prev = points[i-1];
            const curr = points[i];

            const dxKm = (curr.x - prev.x) * routeLength;
            const dyRaw = prev.y - curr.y;
            const dyM = dyRaw > 0 ? dyRaw * scale : 0; // only positive ascent counts for climb height
            const slopePercent = (dxKm !== 0) ? (dyM / (dxKm * 1000)) * 100 : 0;

            const isClimb = dyM > 0; // treat any positive dy as climb primitive (even if slope small)
            let grade = 'flat';
            if (slopePercent >= 40) grade = 'a';
            else if (slopePercent >= 20) grade = 'b';
            else if (slopePercent >= 10) grade = 'c';
            else if (slopePercent >= 5)  grade = 'd';
            else if (slopePercent > 0)   grade = 'e';

            primitives.push({
                start: prev.x,
                end: curr.x,
                dxKm,
                dyM,
                avgSlope: slopePercent,
                isClimb,
                grade
            });
        }

        return primitives;
    }

    // --- Build primitives grouped into blocks of same type (climb vs flat) ---
    function buildBlocks(primitives) {
        const blocks = [];
        if (!primitives.length) return blocks;
        let cur = { ...primitives[0], start:primitives[0].start, end:primitives[0].end };
        for (let i=1;i<primitives.length;i++){
            const p = primitives[i];
            const sameType = (p.isClimb && cur.isClimb) || (!p.isClimb && !cur.isClimb);
            if (sameType) {
                cur.dxKm += p.dxKm;
                cur.dyM += p.dyM;
                cur.end = p.end;
                // avgSlope will be recomputed when needed
            } else {
                // push current block
                cur.avgSlope = (cur.dxKm>0) ? (cur.dyM / (cur.dxKm * 1000)) * 100 : 0;
                blocks.push(cur);
                cur = { ...p, start:p.start, end:p.end };
            }
        }
        cur.avgSlope = (cur.dxKm>0) ? (cur.dyM / (cur.dxKm * 1000)) * 100 : 0;
        blocks.push(cur);
        return blocks;
    }

    // --- Merge logic on blocks according to your rules ---
    function mergeClimbsAndShortFlats(blocks) {
        const merged = [];
        let i = 0;
        while (i < blocks.length) {
            const block = blocks[i];
            if (!block.isClimb) {
                // skip isolated flats ‚Äî they will be absorbed by neighbors if short and between climbs
                i++;
                continue;
            }

            // start new combined climb from this block
            let combined = {
                start: block.start,
                end: block.end,
                dxKm: block.dxKm,
                dyM: block.dyM,
            };

            let j = i + 1;
            while (j < blocks.length) {
                const next = blocks[j];
                if (next.isClimb) {
                    // gap between combined.end and next.start (should be zero if blocks adjacent)
                    const gapKm = next.start * routeLength - combined.end * routeLength;
                    if (gapKm <= MERGE_GAP_KM) {
                        // merge next climb
                        combined.dxKm += next.dxKm;
                        combined.dyM += next.dyM;
                        combined.end = next.end;
                        j++;
                        continue;
                    } else {
                        break;
                    }
                } else {
                    // next is flat block(s). sum consecutive flats
                    let flatTotal = next.dxKm;
                    let k = j;
                    while (k+1 < blocks.length && !blocks[k+1].isClimb) {
                        k++;
                        flatTotal += blocks[k].dxKm;
                    }
                    const afterIdx = k + 1;
                    if (afterIdx < blocks.length && blocks[afterIdx].isClimb) {
                        // there is a climb after these flats
                        if (flatTotal <= MERGE_GAP_KM) {
                            // include flat(s) and the following climb into combined
                            const nextClimb = blocks[afterIdx];
                            combined.dxKm += flatTotal + nextClimb.dxKm;
                            combined.dyM += nextClimb.dyM; // flats add 0 dy
                            combined.end = nextClimb.end;
                            // advance j to after the included nextClimb
                            j = afterIdx + 1;
                            continue;
                        } else {
                            // flats too long: do not absorb next climb
                            break;
                        }
                    } else {
                        // no climb after flats (end of route) -> do not include
                        break;
                    }
                }
            }

            // compute avgSlope for combined
            combined.avgSlope = (combined.dxKm > 0) ? (combined.dyM / (combined.dxKm * 1000)) * 100 : 0;

            merged.push(combined);
            i = j;
        }

        return merged;
    }

    // --- Draw / List logic ---
  let segmentListBuilt = false; // ny flagga h√∂gst upp i scriptet
let climbProgressOverlay; // overlay-element
// --- GLOBAL VAR --- h√∂gst upp i scriptet
// --- GLOBAL VAR --- h√∂gst upp i scriptet
// --- GLOBAL VAR --- h√∂gst upp i scriptet
window.climbProgressOverlay = window.climbProgressOverlay || null;

window.climbProgressBar = window.climbProgressBar || null;

// --- Skapar overlay-rutan med progressbar (enda g√•ngen) ---
function createClimbProgressOverlay() {
    if (window.climbProgressOverlay) return window.climbProgressOverlay;

    const overlay = document.createElement('div');
    Object.assign(overlay.style, {
        position: 'fixed',
        left: '50%',
        transform: 'translateX(-50%)',
        background: '#000c',
        color: 'white',
        padding: '8px 12px',
        borderRadius: '6px',
        fontSize: '13px',
        fontWeight: 'bold',
        zIndex: '9999',
        minWidth: '260px',
        width:'32vw',
        textAlign: 'center',
        transition: 'background 0.2s'
    });

    const textDiv = document.createElement('div');
    textDiv.style.marginBottom = '4px';
    overlay.appendChild(textDiv);

    const barContainer = document.createElement('div');
    Object.assign(barContainer.style, {
        width: '100%',
        height: '12px',
        background: '#2228',
        borderRadius: '6px',
        overflow: 'hidden'
    });

    const bar = document.createElement('div');
    Object.assign(bar.style, {
        width: '0%',
        height: '100%',
        background: 'lime',
        borderRadius: '6px',
        transition: 'width 0.2s'
    });

    barContainer.appendChild(bar);
    overlay.appendChild(barContainer);

    document.body.appendChild(overlay);

    window.climbProgressOverlay = overlay;
    window.climbProgressBar = { bar, textDiv };

    // --- placera precis ovanf√∂r segmentListOverlay ---
    function updatePosition() {
        if(segmentListOverlay){
            const rect = segmentListOverlay.getBoundingClientRect();
            overlay.style.bottom = `${window.innerHeight - rect.top + 8}px`; // 8px mellanrum
        }
    }
    updatePosition();
    window.addEventListener('resize', updatePosition);

    return overlay;
}

// --- Uppdaterar climb progress med progressbar ---
function updateClimbProgress(mergedClimbs, myPosKm) {
    const overlayEl = createClimbProgressOverlay();
    const { bar, textDiv } = window.climbProgressBar;

    if (!mergedClimbs || !mergedClimbs.length) {
        textDiv.textContent = 'No climbs';
        bar.style.width = '0%';
        overlayEl.style.background = '#000c';
        return;
    }

    // Hitta aktuell climb (mitt i climb)
    const activeClimb = mergedClimbs.find(c => {
        const climbStartInv = routeLength - c.start * routeLength;
        const climbEndInv = routeLength - c.end * routeLength;
        return myPosKm <= climbStartInv && myPosKm >= climbEndInv;
    });

    // Filtrera climbs f√∂r segmentlistan / kommande climbs
    let climbsToShow = mergedClimbs.filter(c => c.avgSlope >= DISPLAY_SLOPE_THRESHOLD);
    if (activeClimb && !climbsToShow.includes(activeClimb)) {
        climbsToShow.unshift(activeClimb); // alltid visa aktuell climb
    }

    if (!climbsToShow.length) {
        textDiv.textContent = 'No climbs above threshold';
        bar.style.width = '0%';
        overlayEl.style.background = '#000c';
        return;
    }

    // Hitta n√§sta climb f√∂r progress
    let nextClimb = null;
    let nextIndex = -1;
    for (let i = 0; i < climbsToShow.length; i++) {
        const climb = climbsToShow[i];
        const climbStartInv = routeLength - climb.start * routeLength;
        const climbEndInv = routeLength - climb.end * routeLength;

        if (myPosKm <= climbStartInv && myPosKm >= climbEndInv) {
            nextClimb = climb;
            nextIndex = i;
            break;
        } else if (myPosKm > climbStartInv) {
            nextClimb = climb;
            nextIndex = i;
            break;
        }
    }

    if (!nextClimb) {
        if (window.climbFinishedTime && Date.now() - window.climbFinishedTime < 10000) {
            textDiv.textContent = window.lastClimbText || 'Finished all climbs';
            bar.style.width = '100%';
        } else {
            textDiv.textContent = 'Finished all climbs';
            bar.style.width = '100%';
            window.currentClimbStartTime = null;
            window.currentClimbIndex = -1;
            window.climbFinishedTime = null;
        }
        overlayEl.style.background = '#000c';
        return;
    }

    const climbStartInv = routeLength - nextClimb.start * routeLength;
    const climbEndInv   = routeLength - nextClimb.end * routeLength;

    let displayText = '';
    let bgColor = '#000c';
    let progressPercent = 0;

    const now = Date.now();

    if (myPosKm > climbStartInv) {
        // f√∂re climb
        displayText = `Next climb #${nextIndex + 1} in: ${(myPosKm - climbStartInv).toFixed(2)} km`;
        progressPercent = 0;
        bgColor = '#0008';
        window.currentClimbStartTime = null;
        window.currentClimbIndex = -1;
    } else if (myPosKm <= climbStartInv && myPosKm >= climbEndInv) {
        // p√• climb ‚Äì IGNORERA DISPLAY_SLOPE_THRESHOLD
        const climbRemainingKm = myPosKm - climbEndInv;
        const climbTotalKm     = climbStartInv - climbEndInv;
        const climbRemainingM  = nextClimb.dyM * (climbRemainingKm / climbTotalKm);

        // --- NYTT: avg slope remaining ---
        const avgSlopeRemaining = (climbRemainingKm > 0) ? (climbRemainingM / (climbRemainingKm * 1000)) * 100 : 0;

        // H√§mta aktuell speed f√∂r ETA
        let speedKPH = 0;
        const statsGrid = document.querySelector('.stats-grid');
        if (statsGrid) {
            const statRows = statsGrid.querySelectorAll('.stat-row.svelte-1wfcwp8');
            if (statRows.length >= 1) {
                const speedEl = statRows[0].querySelector('.stat-row-split.stat-avg .avg-value.svelte-1wfcwp8');
                if (speedEl) speedKPH = parseFloat(speedEl.textContent.trim()) || 0;
            }
        }

        // tid kvar
        let timeRemainingText = '--';
        if (speedKPH > 0) {
            const hours = climbRemainingKm / speedKPH;
            const minutes = Math.floor(hours * 60);
            const seconds = Math.round((hours * 3600) % 60);
            timeRemainingText = `${minutes}m ${seconds}s`;
        }

        // starta ny climb om den √§r ny
        if (window.currentClimbIndex !== nextIndex) {
            window.currentClimbStartTime = now;
            window.currentClimbIndex = nextIndex;
            window.climbFinishedTime = null;
        }

        let elapsedText = '';
        if (window.currentClimbStartTime) {
            const elapsedSec = Math.floor((now - window.currentClimbStartTime) / 1000);
            const elapsedMin = Math.floor(elapsedSec / 60);
            const elapsedRem = elapsedSec % 60;
            elapsedText = ` | Duration: ${elapsedMin}m ${elapsedRem}s`;
        }

        displayText = `Climb #${nextIndex + 1} remaining: ${climbRemainingKm.toFixed(2)} km | ${climbRemainingM.toFixed(2)} m | Avg Grade: ${avgSlopeRemaining.toFixed(2)}% | ETA: ${timeRemainingText}${elapsedText}`;
        progressPercent = ((climbTotalKm - climbRemainingKm) / climbTotalKm) * 100;

        let grade = 'e';
        if (nextClimb.avgSlope >= 40) grade='a';
        else if (nextClimb.avgSlope >= 20) grade='b';
        else if (nextClimb.avgSlope >= 10) grade='c';
        else if (nextClimb.avgSlope >= 5)  grade='d';

        bgColor = getGradeColor(grade) + '88';
    }

    // om climb √§r klar, spara text f√∂r 10 sekunder
    if (myPosKm < climbEndInv && window.currentClimbIndex === nextIndex) {
        window.climbFinishedTime = now;
        window.lastClimbText = displayText;
        window.currentClimbStartTime = null;
        window.currentClimbIndex = -1;
    }

    textDiv.textContent = displayText;
    bar.style.width = progressPercent.toFixed(2) + '%';
    overlayEl.style.background = bgColor;
}

function drawSegments(mergedClimbs, primitives) {
    const overlayEl = overlay;
    if(!overlayEl) return;
    const overlaySvg = overlay.querySelector('svg');
    const width = overlayEl.clientWidth;
    const height = overlaySvg.clientHeight;

    // clear old rects (f√∂r overlay) - alltid rita linjer f√∂r position
    segmentRects.forEach(r=>r.remove());
    segmentRects = [];

    createSegmentListOverlay();

    // --- NYTT: bygg segment listan bara EN g√•ng ---
    if(!segmentListBuilt) {
        segmentListContainer.innerHTML = '';

        // Vi bygger listan p√• samma s√§tt som tidigare
        let totalHeightFromPrimitives = 0;
        primitives.forEach(p => { totalHeightFromPrimitives += (p.dyM || 0); });

        let displayIndex = 1;
        for (let m of mergedClimbs) {
            if (m.avgSlope < DISPLAY_SLOPE_THRESHOLD) continue;

            const startKm = (m.start * routeLength) || 0;
            const endKm = (m.end * routeLength) || 0;
            const lenKm = Math.max(0, endKm - startKm);

const div = document.createElement('div');
div.style.display = 'flex';
div.style.justifyContent = 'space-between';
div.style.padding = '4px 0';
div.style.borderBottom = '1px dashed rgba(255,255,255,0.04)';
//div.style.fontFamily = 'monospace';
div.style.whiteSpace = 'nowrap'; // <--- ingen radbrytning
div.style.overflow = 'hidden';
div.style.textOverflow = 'ellipsis';

const colStyle = 'flex:1; text-align:right; overflow:hidden; text-overflow:ellipsis;';

div.innerHTML = `
    <div style="flex:1; text-align:left;">#${displayIndex} CLIMB</div>
    <div style="${colStyle}">${startKm.toFixed(2)}‚Üí${endKm.toFixed(2)} km</div>
    <div style="${colStyle}">${lenKm.toFixed(2)} km</div>
    <div style="${colStyle}">${m.dyM.toFixed(0)} m</div>
    <div style="${colStyle}">${m.avgSlope.toFixed(2)}%</div>
`;
segmentListContainer.appendChild(div);

            displayIndex++;
        }



        segmentListBuilt = true; // flagga att listan nu √§r byggd
    }

    // --- Overlay rektanglar (kl√§ttringar) ritas alltid dynamiskt ---
    for (let m of mergedClimbs) {
        if (m.avgSlope < DISPLAY_SLOPE_THRESHOLD) continue;

        const x = m.start * width;
        const w = Math.max(1, (m.end - m.start) * width);

        const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute('x', x);
        rect.setAttribute('y', 0);
        rect.setAttribute('width', w);
        rect.setAttribute('height', height);

        let grade = 'e';
        if (m.avgSlope >= 40) grade='a';
        else if (m.avgSlope >= 20) grade='b';
        else if (m.avgSlope >= 10) grade='c';
        else if (m.avgSlope >= 5) grade='d';
        else grade='e';

        rect.setAttribute('fill', getGradeColor(grade));
        rect.setAttribute('opacity', 0.36);
        overlaySvg.appendChild(rect);
        segmentRects.push(rect);
    }
}

    // --- Main update ---
    function updateOverlay() {
        const overlayEl = createOverlay();
        const pos = getLeaderAndMyPos(false);
if (pos.myPosKm >= routeLength) {
    autoUpdateSegmentList(pos);
}
       // logContainer.textContent = `MyPos ${pos.myPosKm.toFixed(1)} km`;

        const svg = overlayEl.querySelector('svg');
        const width = overlayEl.clientWidth;
        const height = svg.clientHeight;

        if(!routeLength) return;

        const targetMyX = ((routeLength - pos.myPosKm) / routeLength) * width;
        const leaderAbs = pos.myPosKm - pos.leaderKm;
        const targetLeaderX = ((routeLength - leaderAbs) / routeLength) * width;

        currentMyX += (targetMyX - currentMyX) * 0.2;
        currentLeaderX += (targetLeaderX - currentLeaderX) * 0.2;

        myPosLine.setAttribute('x1',currentMyX);
        myPosLine.setAttribute('x2',currentMyX);
        myPosLine.setAttribute('y2',height);

        leaderLine.setAttribute('x1',currentLeaderX);
        leaderLine.setAttribute('x2',currentLeaderX);
        leaderLine.setAttribute('y2',height);

        // compute primitives (no merge) with correct scaling
        const primitives = computePrimitives();

        // build blocks of same type (climb vs flat)
        const blocks = buildBlocks(primitives);

        // merge climbs and short flats between them
        const mergedClimbs = mergeClimbsAndShortFlats(blocks);

        // draw only merged climbs that meet display threshold, and the total from primitives
        drawSegments(mergedClimbs, primitives);
        updateClimbProgress(mergedClimbs, pos.myPosKm);
if(window.climbProgressOverlay && segmentListOverlay){
            const rect = segmentListOverlay.getBoundingClientRect();
            window.climbProgressOverlay.style.bottom = `${window.innerHeight - rect.top + 8}px`;
        }
    }

    setInterval(updateOverlay, checkInterval);
    setTimeout(()=>getLeaderAndMyPos(true), 1500);

// Initiera manuellt UI direkt n√§r scriptet startar
createManualRouteSettings();

})();


    // --- OBSERVER F√ñR ATT D√ñLJA OM .workout-wrap DYKER UPP ---
    const observer = new MutationObserver(() => {
        const workoutWrapExists = !!document.querySelector(".workout-wrap");
        if(workoutWrapExists) {
            console.log("üõë workout-wrap uppt√§ckt ‚Äì overlays g√∂mda");
            if(window.overlay) window.overlay.style.display = 'none';
            if(window.segmentListOverlay) window.segmentListOverlay.style.display = 'none';
            if(window.climbProgressOverlay) window.climbProgressOverlay.style.display = 'none';
        }
    });

    observer.observe(document.body, { childList: true, subtree: true });

})();
